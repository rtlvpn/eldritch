<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRX/USDT Orderbook Heatmap, CVD Chart & Bookmap</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
        }
        #container {
            width: 800px;
            margin: 20px auto;
            text-align: center;
        }
        #title {
            font-size: 24px;
            color: #333;
            margin-bottom: 10px;
        }
        /* Styles for visualizations */
        #heatmap, #cvdchart, #bookmap {
            background: white;
            border: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        #heatmap svg, #cvdchart svg, #bookmap svg {
            border: 1px solid black; /* For debugging SVG boundaries */
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="title">TRX/USDT Orderbook Heatmap, CVD Chart & Bookmap</div>
        <div id="heatmap"></div>
        <div id="cvdchart"></div>
        <div id="bookmap"></div>
    </div>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script>
        // --- Constants for Heatmap ---
        const binSize = 0.0001;
        const rangeFactor = 100; // Might tweak this later
        const width = 800;
        const height = 600;
        const margin = { top: 20, right: 20, bottom: 30, left: 50 };
        const innerWidth = width - margin.left - margin.right;
        const innerHeight = height - margin.top - margin.bottom;

        // --- Global Orderbook storage ---
        let bids = {};
        let asks = {};

        // --- D3.js elements for heatmap ---
        let svg, g, yScale, yAxis, bidRects, askRects, bidColor, askColor;

        // --- Global D3.js elements for CVD Chart ---
        let cvdSvg, cvdG, cvdXScale, cvdYScale, cvdXAxis, cvdYAxis;
        const cvdWidth = 800, cvdHeight = 300;
        const cvdMargin = { top: 20, right: 20, bottom: 30, left: 50 };
        const cvdInnerWidth = cvdWidth - cvdMargin.left - cvdMargin.right;
        const cvdInnerHeight = cvdHeight - cvdMargin.top - cvdMargin.bottom;

        // --- Global variables for Bookmap ---
        // We will record snapshots (bins) over time and render as columns.
        let bookmapHistory = [];
        const maxHistory = 60; // e.g. 60 snapshots (seconds)
        let bookmapSvg, bookmapG, bookmapXScale, bookmapYScale;
        const bookmapWidth = 800, bookmapHeight = 300;
        const bookmapMargin = { top: 20, right: 20, bottom: 30, left: 50 };
        const bookmapInnerWidth = bookmapWidth - bookmapMargin.left - bookmapMargin.right;
        const bookmapInnerHeight = bookmapHeight - bookmapMargin.top - bookmapMargin.bottom;

        function initializeVisualization() {
            // --- Heatmap SVG setup ---
            svg = d3.select('#heatmap')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            g = svg.append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);

            // Background for heatmap SVG
            g.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', innerWidth)
                .attr('height', innerHeight)
                .attr('fill', 'lightgray');

            yScale = d3.scaleLinear()
                .range([0, innerHeight]);

            yAxis = g.append('g')
                .attr('class', 'y-axis');

            bidColor = d3.scaleLinear()
                .range(['#e6ffe6', '#006400']); // Light to dark green

            askColor = d3.scaleLinear()
                .range(['#ffe6e6', '#8b0000']); // Light to dark red

            // --- CVD Chart SVG setup ---
            cvdSvg = d3.select('#cvdchart')
                .append('svg')
                .attr('width', cvdWidth)
                .attr('height', cvdHeight);

            cvdG = cvdSvg.append('g')
                .attr('transform', `translate(${cvdMargin.left},${cvdMargin.top})`);

            // Background for CVD chart
            cvdG.append('rect')
                .attr('x', 0)
                .attr('y', 0)
                .attr('width', cvdInnerWidth)
                .attr('height', cvdInnerHeight)
                .attr('fill', 'lightgray');

            cvdXScale = d3.scaleLinear()
                .range([0, cvdInnerWidth]);

            cvdYScale = d3.scaleLinear()
                .range([cvdInnerHeight, 0]);

            cvdXAxis = cvdG.append('g')
                .attr('class', 'x-axis')
                .attr('transform', `translate(0, ${cvdInnerHeight})`);

            cvdYAxis = cvdG.append('g')
                .attr('class', 'y-axis');

            // --- Bookmap SVG setup ---
            bookmapSvg = d3.select('#bookmap')
                .append('svg')
                .attr('width', bookmapWidth)
                .attr('height', bookmapHeight);

            bookmapG = bookmapSvg.append('g')
                .attr('transform', `translate(${bookmapMargin.left},${bookmapMargin.top})`);

            // Background for Bookmap chart
            bookmapG.append('rect')
                .attr('width', bookmapInnerWidth)
                .attr('height', bookmapInnerHeight)
                .attr('fill', 'lightgray');

            // X scale for Bookmap (time axis)
            bookmapXScale = d3.scaleLinear()
                .domain([0, maxHistory])
                .range([0, bookmapInnerWidth]);
        }

        // --- Initialize orderbook and visualizations ---
        fetch('https://api.binance.com/api/v3/depth?symbol=TRXUSDT&limit=1000')
            .then(response => response.json())
            .then(data => {
                bids = Object.fromEntries(data.bids.map(([p, q]) => [p, parseFloat(q)]));
                asks = Object.fromEntries(data.asks.map(([p, q]) => [p, parseFloat(q)]));
                console.log('Initial bids:', Object.keys(bids).length, 'asks:', Object.keys(asks).length);
                initializeVisualization();
                connectWebSocket();
                setInterval(updateHeatmap, 1000);
            })
            .catch(error => console.error('Error fetching initial orderbook:', error));

        function connectWebSocket() {
            const ws = new WebSocket('wss://stream.binance.com:9443/ws/trxusdt@depth');
            ws.onmessage = event => {
                const message = JSON.parse(event.data);
                applyDiff(message);
            };
            ws.onerror = () => console.error('WebSocket error');
            ws.onclose = () => setTimeout(connectWebSocket, 1000);
        }

        function applyDiff(message) {
            message.b.forEach(([price, qty]) => {
                qty = parseFloat(qty);
                if (qty === 0) delete bids[price];
                else bids[price] = qty;
            });
            message.a.forEach(([price, qty]) => {
                qty = parseFloat(qty);
                if (qty === 0) delete asks[price];
                else asks[price] = qty;
            });
        }

        function updateHeatmap() {
            const bidPrices = Object.keys(bids).filter(p => bids[p] > 0).map(parseFloat);
            const askPrices = Object.keys(asks).filter(p => asks[p] > 0).map(parseFloat);
            console.log('Filtered bidPrices:', bidPrices.length, 'askPrices:', askPrices.length);
            if (bidPrices.length === 0 || askPrices.length === 0) return;

            const bestBid = Math.max(...bidPrices);
            const bestAsk = Math.min(...askPrices);
            const midPrice = (bestBid + bestAsk) / 2;
            console.log('Best Bid:', bestBid, 'Best Ask:', bestAsk, 'Mid Price:', midPrice);

            const priceMin = midPrice - rangeFactor * binSize;
            const priceMax = midPrice + rangeFactor * binSize;
            console.log('Price Min:', priceMin, 'Price Max:', priceMax);

            // Update heatmap yScale (price axis)
            yScale.domain([priceMax, priceMin]);

            yAxis.call(d3.axisLeft(yScale)
                .ticks(10)
                .tickFormat(d3.format('.6f')));

            // Create bins for orderbook data
            const bins = d3.range(priceMin, priceMax, binSize)
                .map(price => ({ price, bidVolume: 0, askVolume: 0 }));

            for (const p in bids) {
                const price = parseFloat(p);
                if (price >= priceMin && price < priceMax) {
                    const index = Math.floor((price - priceMin) / binSize);
                    if (index >= 0 && index < bins.length) bins[index].bidVolume += bids[p];
                }
            }
            for (const p in asks) {
                const price = parseFloat(p);
                if (price >= priceMin && price < priceMax) {
                    const index = Math.floor((price - priceMin) / binSize);
                    if (index >= 0 && index < bins.length) bins[index].askVolume += asks[p];
                }
            }

            console.log('Bins with bidVolume > 0:', bins.filter(d => d.bidVolume > 0).length);
            console.log('Bins with askVolume > 0:', bins.filter(d => d.askVolume > 0).length);

            const maxBidVolume = d3.max(bins, d => d.bidVolume) || 1;
            const maxAskVolume = d3.max(bins, d => d.askVolume) || 1;
            bidColor.domain([0, maxBidVolume]);
            askColor.domain([0, maxAskVolume]);

            // Update rectangles for bid heatmap in the primary heatmap
            bidRects = g.selectAll('.bid-rect')
                .data(bins)
                .join('rect')
                .attr('class', 'bid-rect')
                .attr('x', 0)
                .attr('width', innerWidth / 2)
                .attr('y', d => yScale(d.price + binSize))
                .attr('height', d => yScale(d.price) - yScale(d.price + binSize))
                .attr('fill', d => bidColor(d.bidVolume));

            // Update rectangles for ask heatmap in the primary heatmap
            askRects = g.selectAll('.ask-rect')
                .data(bins)
                .join('rect')
                .attr('class', 'ask-rect')
                .attr('x', innerWidth / 2)
                .attr('width', innerWidth / 2)
                .attr('y', d => yScale(d.price + binSize))
                .attr('height', d => yScale(d.price) - yScale(d.price + binSize))
                .attr('fill', d => askColor(d.askVolume));

            // Draw best bid line
            g.selectAll('.best-bid')
                .data([bestBid])
                .join('line')
                .attr('class', 'best-bid')
                .attr('x1', 0)
                .attr('x2', innerWidth)
                .attr('y1', d => yScale(d))
                .attr('y2', d => yScale(d))
                .attr('stroke', 'blue')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '4');

            // Draw best ask line
            g.selectAll('.best-ask')
                .data([bestAsk])
                .join('line')
                .attr('class', 'best-ask')
                .attr('x1', 0)
                .attr('x2', innerWidth)
                .attr('y1', d => yScale(d))
                .attr('y2', d => yScale(d))
                .attr('stroke', 'orange')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '4');

            // --- CVD Chart Update ---
            let cumulative = 0;
            const cvdData = bins.map(bin => {
                cumulative += (bin.bidVolume - bin.askVolume);
                return { price: bin.price, cvd: cumulative };
            });

            cvdXScale.domain([priceMin, priceMax]);
            const minCvd = d3.min(cvdData, d => d.cvd);
            const maxCvd = d3.max(cvdData, d => d.cvd);
            cvdYScale.domain([Math.min(minCvd, 0), Math.max(maxCvd, 0)]);

            const cvdArea = d3.area()
                .x(d => cvdXScale(d.price))
                .y0(cvdYScale(0))
                .y1(d => cvdYScale(d.cvd))
                .curve(d3.curveBasis);

            const cvdLine = d3.line()
                .x(d => cvdXScale(d.price))
                .y(d => cvdYScale(d.cvd))
                .curve(d3.curveBasis);

            cvdG.selectAll(".cvd-area")
                .data([cvdData])
                .join("path")
                .attr("class", "cvd-area")
                .attr("fill", "steelblue")
                .attr("opacity", 0.3)
                .attr("d", cvdArea);

            cvdG.selectAll(".cvd-line")
                .data([cvdData])
                .join("path")
                .attr("class", "cvd-line")
                .attr("fill", "none")
                .attr("stroke", "steelblue")
                .attr("stroke-width", 2)
                .attr("d", cvdLine);

            cvdXAxis.call(d3.axisBottom(cvdXScale)
                .tickFormat(d3.format('.6f')));
            cvdYAxis.call(d3.axisLeft(cvdYScale));

            // --- Bookmap Update ---
            // Save current bins snapshot in history.
            bookmapHistory.push(bins);
            if (bookmapHistory.length > maxHistory) {
                bookmapHistory.shift();
            }
            updateBookmap();
        }

        function updateBookmap() {
            // Update the Bookmap Y scale using the current price range
            // (same as in the primary heatmap)
            bookmapYScale = d3.scaleLinear()
                .domain(yScale.domain())
                .range([0, bookmapInnerHeight]);

            const columnWidth = bookmapInnerWidth / maxHistory;

            // Bind the history data (each snapshot is one column)
            const snapshots = bookmapG.selectAll('.snapshot')
                .data(bookmapHistory);

            const snapshotsEnter = snapshots.enter()
                .append('g')
                .attr('class', 'snapshot');

            snapshotsEnter.merge(snapshots)
                .attr('transform', (d, i) => `translate(${i * columnWidth},0)`);

            snapshots.exit().remove();

            // For each snapshot, draw bid and ask rectangles.
            snapshotsEnter.merge(snapshots).each(function(snapshot) {
                const group = d3.select(this);

                // Draw bid rectangles (left half of the column)
                const bidRects = group.selectAll('.bid-rect')
                    .data(snapshot, d => d.price);
                bidRects.enter().append('rect')
                    .attr('class', 'bid-rect')
                    .merge(bidRects)
                    .attr('x', 0)
                    .attr('width', columnWidth / 2)
                    .attr('y', d => bookmapYScale(d.price + binSize))
                    .attr('height', d => bookmapYScale(d.price) - bookmapYScale(d.price + binSize))
                    .attr('fill', d => bidColor(d.bidVolume));
                bidRects.exit().remove();

                // Draw ask rectangles (right half of the column)
                const askRects = group.selectAll('.ask-rect')
                    .data(snapshot, d => d.price);
                askRects.enter().append('rect')
                    .attr('class', 'ask-rect')
                    .merge(askRects)
                    .attr('x', columnWidth / 2)
                    .attr('width', columnWidth / 2)
                    .attr('y', d => bookmapYScale(d.price + binSize))
                    .attr('height', d => bookmapYScale(d.price) - bookmapYScale(d.price + binSize))
                    .attr('fill', d => askColor(d.askVolume));
                askRects.exit().remove();
            });
        }
    </script>
</body>
</html>
