<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binance Order Book Heatmap</title>
  <style>
    /* Basic reset and dark theme */
    html, body {
      margin: 0;
      padding: 0;
      background-color: #121212;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    /* Fullscreen canvas */
    canvas {
      display: block;
    }
    /* Optional overlay showing last update time */
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="heatmapCanvas"></canvas>
    <div id="overlay">Last update: <span id="lastUpdate">N/A</span></div>
  </div>
  
  <script>
    // Get references to DOM elements.
    const canvas = document.getElementById('heatmapCanvas');
    const ctx = canvas.getContext('2d');
    const overlayLastUpdate = document.getElementById('lastUpdate');

    // Adjust canvas dimensions to fill the window.
    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      if (currentData) drawHeatmap(currentData);
    }
    window.addEventListener('resize', resizeCanvas);

    // Global variable to store the latest heatmap data.
    let currentData = null;

    // Fetch the heatmap data from our API endpoint.
    async function fetchHeatmap() {
      try {
        const response = await fetch('http://62.60.251.230:3500/api/orderbook/heatmap');
        const data = await response.json();
        currentData = data;
        overlayLastUpdate.textContent = new Date().toLocaleTimeString();
        drawHeatmap(data);
      } catch (error) {
        console.error('Error fetching heatmap data:', error);
      }
    }

    // Draw the heatmap on the canvas.
    function drawHeatmap(data) {
      if (!data || !data.times || data.times.length === 0) {
        // No data available; clear the canvas and show a message.
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = "#fff";
        ctx.font = "20px Arial";
        ctx.fillText("No heatmap data available", 50, 50);
        return;
      }

      const times = data.times;      // Array of tick timestamps.
      const buckets = data.buckets;  // Price bucket boundaries.
      const bidHeat = data.bidHeat;  // 2D array: each row corresponds to a tick's bid volumes.
      const askHeat = data.askHeat;  // 2D array: each row corresponds to a tick's ask volumes.
      
      // Determine grid dimensions.
      const numTicks = times.length;
      const numBuckets = buckets.length;
      const cellWidth = canvas.width / numTicks;
      const cellHeight = canvas.height / numBuckets;

      // Compute global maximum volume (for normalization) from both bid and ask cells.
      let maxVolume = 0;
      for (let i = 0; i < numTicks; i++) {
        for (let j = 0; j < numBuckets; j++) {
          const vol = (bidHeat[i][j] || 0) + (askHeat[i][j] || 0);
          if (vol > maxVolume) maxVolume = vol;
        }
      }

      // Clear the canvas.
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Draw heatmap cells.
      for (let i = 0; i < numTicks; i++) {
        for (let j = 0; j < numBuckets; j++) {
          const bidVol = bidHeat[i][j] || 0;
          const askVol = askHeat[i][j] || 0;
          const totalVol = bidVol + askVol;
          
          // Normalize the volumes. A square-root scale helps with visualization.
          const bidIntensity = Math.sqrt(bidVol / maxVolume);
          const askIntensity = Math.sqrt(askVol / maxVolume);

          // Build a color with red for asks and blue for bids.
          // When both orders exist, the combination produces a purple hue.
          const red = Math.min(255, Math.floor(askIntensity * 255));
          const blue = Math.min(255, Math.floor(bidIntensity * 255));
          const cellColor = `rgb(${red}, 0, ${blue})`;

          // Calculate cell position.
          const x = i * cellWidth;
          // Invert the y-axis so that higher price buckets (higher indices) appear at the top.
          const y = canvas.height - (j + 1) * cellHeight;

          ctx.fillStyle = cellColor;
          ctx.fillRect(x, y, cellWidth, cellHeight);
        }
      }

      // Optionally, draw price axis labels along the left side.
      ctx.fillStyle = "#fff";
      ctx.font = "12px Arial";
      const priceStep = Math.max(1, Math.floor(numBuckets / 10));
      for (let j = 0; j < numBuckets; j += priceStep) {
        const priceLabel = Number(buckets[j]).toFixed(4);
        // Center the text within the cell.
        const y = canvas.height - (j + 0.5) * cellHeight;
        ctx.fillText(priceLabel, 5, y);
      }

      // Optionally, draw time axis labels along the bottom.
      const timeStep = Math.max(1, Math.floor(numTicks / 10));
      for (let i = 0; i < numTicks; i += timeStep) {
        const timeLabel = new Date(times[i]).toLocaleTimeString();
        const x = i * cellWidth;
        ctx.fillText(timeLabel, x, canvas.height - 5);
      }
    }

    // Initial fetch and schedule auto-refresh.
    fetchHeatmap();
    setInterval(fetchHeatmap, 5000); // refresh every 5 seconds

    // Resize the canvas on load.
    resizeCanvas();
  </script>
</body>
</html>
