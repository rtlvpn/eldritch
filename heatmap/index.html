<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binance Order Book Heatmap (Plotly)</title>
  <!-- Include Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    /* Basic reset and dark theme */
    html, body {
      margin: 0;
      padding: 0;
      background-color: #0a0a0a;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    /* Fill the container with the Plotly plot */
    #heatmapPlot {
      width: 100%;
      height: 100%;
    }
    /* Overlay for last update time. */
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    /* Control panel */
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    button {
      background: #333;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      border-radius: 3px;
      cursor: pointer;
    }
    button:hover {
      background: #555;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Plotly will use this div for the heatmap -->
    <div id="heatmapPlot"></div>
    <div id="overlay">Last update: <span id="lastUpdate">N/A</span></div>
    <div id="controls">
      <button id="resetZoom">Reset View</button>
      <button id="toggleColorScale">Toggle Colorscale</button>
    </div>
  </div>
  
  <script>
    // References to DOM elements
    const overlayLastUpdate = document.getElementById('lastUpdate');
    const resetZoomBtn = document.getElementById('resetZoom');
    const toggleColorScaleBtn = document.getElementById('toggleColorScale');
    
    // Global state
    let useAlternateColorScale = false;
    let currentLayout = {};
    
    // Color schemes
    const colorSchemes = {
      default: {
        intensity: [
          [0, 'rgb(0,0,0)'],
          [0.3, 'rgb(25,25,35)'],
          [0.7, 'rgb(60,60,80)'],
          [1, 'rgb(130,130,160)']
        ],
        imbalance: [
          [0, 'rgb(0,80,180)'],     // Deep blue for bid dominance
          [0.4, 'rgb(40,100,160)'], // Subtle blue for slight bid
          [0.5, 'rgb(40,40,60)'],   // Dark neutral for balance (not purple)
          [0.6, 'rgb(160,80,80)'],  // Subtle red for slight ask
          [1, 'rgb(180,50,40)']     // Deep red for ask dominance
        ]
      },
      alternate: {
        intensity: [
          [0, 'rgb(0,0,0)'],
          [0.4, 'rgb(15,25,25)'],
          [0.8, 'rgb(30,50,60)'],
          [1, 'rgb(60,100,110)']
        ],
        imbalance: [
          [0, 'rgb(0,60,120)'],     // Darker blue
          [0.4, 'rgb(40,90,120)'],  // Muted blue-teal
          [0.5, 'rgb(30,40,50)'],   // Very dark neutral
          [0.6, 'rgb(100,60,60)'],  // Muted red-brown
          [1, 'rgb(120,40,30)']     // Darker red
        ]
      }
    };
    
    // Fetch and update our Plotly heatmap.
    async function fetchHeatmap() {
      try {
        const response = await fetch('https://eldritch.gleeze.com:3500/api/orderbook/heatmap');
        const data = await response.json();
        overlayLastUpdate.textContent = new Date().toLocaleTimeString();
        drawHeatmap(data);
      } catch (error) {
        console.error('Error fetching heatmap data:', error);
      }
    }
    
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const seconds = date.getSeconds().toString().padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    }
    
    function drawHeatmap(data) {
      if (!data || !data.times || data.times.length === 0) {
        document.getElementById('heatmapPlot').innerHTML =
          '<div style="color:#fff;font-size:20px;padding:20px;">No heatmap data available</div>';
        return;
      }
      
      // Unpack the API data.
      const times = data.times;
      const buckets = data.buckets;
      const bidHeat = data.bidHeat;
      const askHeat = data.askHeat;
      
      const numTicks = times.length;
      const numBuckets = buckets.length;
      
      // Format x-axis labels (time)
      const xLabels = times.map(formatTime);
      
      // Calculate the global maximum volume for normalization.
      let maxVolume = 0;
      for (let i = 0; i < numTicks; i++) {
        for (let j = 0; j < numBuckets; j++) {
          const bid = (bidHeat[i] && bidHeat[i][j]) ? bidHeat[i][j] : 0;
          const ask = (askHeat[i] && askHeat[i][j]) ? askHeat[i][j] : 0;
          const vol = bid + ask;
          if (vol > maxVolume) maxVolume = vol;
        }
      }
      if (maxVolume === 0) maxVolume = 1;
      
      // We want the highest price at the top
      const totalMatrix = [];
      const diffMatrix = [];
      const hoverText = [];
      
      // Prepare y-axis labels (price) in reversed order.
      const yLabels = [];
      
      // Calculate the price format precision based on the values
      let priceDecimals = 4;
      const firstPrice = Number(buckets[0]);
      if (firstPrice >= 1000) priceDecimals = 2;
      else if (firstPrice >= 100) priceDecimals = 3;
      
      for (let r = 0; r < numBuckets; r++) {
        const bucketIndex = numBuckets - 1 - r;
        // Format the price for the label with dynamic precision
        yLabels.push(Number(buckets[bucketIndex]).toFixed(priceDecimals));
        
        totalMatrix[r] = [];
        diffMatrix[r] = [];
        hoverText[r] = [];
        
        for (let i = 0; i < numTicks; i++) {
          const bid = (bidHeat[i] && bidHeat[i][bucketIndex]) ? bidHeat[i][bucketIndex] : 0;
          const ask = (askHeat[i] && askHeat[i][bucketIndex]) ? askHeat[i][bucketIndex] : 0;
          
          // Use a cube-root scale for better visual dynamics with large volume variations
          const I_bid = Math.cbrt(bid / maxVolume);
          const I_ask = Math.cbrt(ask / maxVolume);
          
          // Total intensity and imbalance
          totalMatrix[r][i] = I_bid + I_ask;
          diffMatrix[r][i] = I_ask - I_bid;
          
          // Enhanced hover text
          const bidColor = bid > ask ? "<span style='color:#8af'>↑</span>" : "";
          const askColor = ask > bid ? "<span style='color:#f88'>↓</span>" : "";
          
          hoverText[r][i] = 
            `<b>Time:</b> ${formatTime(times[i])}<br>` +
            `<b>Price:</b> ${Number(buckets[bucketIndex]).toFixed(priceDecimals)}<br>` +
            `<b>Bid:</b> ${bid.toLocaleString()} ${bidColor}<br>` +
            `<b>Ask:</b> ${ask.toLocaleString()} ${askColor}<br>` +
            `<b>Ratio:</b> ${bid+ask > 0 ? (bid/(bid+ask)*100).toFixed(1) + '%' : 'N/A'} bid`;
        }
      }
      
      // Get the selected color scheme
      const colorScheme = useAlternateColorScale ? colorSchemes.alternate : colorSchemes.default;
      
      // Trace 1: Overall intensity
      const traceTotal = {
        z: totalMatrix,
        x: xLabels,
        y: yLabels,
        type: 'heatmap',
        colorscale: colorScheme.intensity,
        zmin: 0,
        zmax: 2,
        showscale: false,
        hoverinfo: 'skip'
      };
      
      // Trace 2: Bid/Ask imbalance
      const traceDiff = {
        z: diffMatrix,
        x: xLabels,
        y: yLabels,
        type: 'heatmap',
        colorscale: colorScheme.imbalance,
        zmin: -1,
        zmax: 1,
        opacity: 0.8,
        showscale: false,
        text: hoverText,
        hoverinfo: 'text',
        hoverlabel: {
          bgcolor: 'rgba(0,0,0,0.8)',
          bordercolor: '#444',
          font: {size: 12, color: 'white'}
        }
      };
      
      // Layout with better readability and formatting
      currentLayout = {
        margin: { l: 70, r: 20, t: 30, b: 60 },
        paper_bgcolor: '#0a0a0a',
        plot_bgcolor: '#0a0a0a',
        xaxis: {
          title: 'Time',
          tickangle: -45,
          tickfont: { size: 10, color: '#ddd' },
          titlefont: { color: '#fff', size: 14 },
          gridcolor: '#222',
          zeroline: false,
          nticks: 10
        },
        yaxis: {
          title: 'Price',
          tickfont: { size: 11, color: '#ddd' },
          titlefont: { color: '#fff', size: 14 },
          gridcolor: '#222',
          zeroline: false
        },
        dragmode: 'zoom',
        modebar: {
          orientation: 'v',
          bgcolor: 'rgba(0,0,0,0.7)',
          color: '#fff',
          activecolor: '#80ccff'
        }
      };
      
      // Configuration for better interactivity
      const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToAdd: [
          'zoom2d',
          'pan2d',
          'zoomIn2d',
          'zoomOut2d',
          'autoScale2d',
          'resetScale2d'
        ],
        modeBarButtonsToRemove: ['toImage', 'sendDataToCloud'],
        displaylogo: false,
        scrollZoom: true
      };
      
      Plotly.newPlot('heatmapPlot', [traceTotal, traceDiff], currentLayout, config);
    }
    
    // Event handlers for controls
    resetZoomBtn.addEventListener('click', () => {
      Plotly.relayout('heatmapPlot', {
        'xaxis.autorange': true,
        'yaxis.autorange': true
      });
    });
    
    toggleColorScaleBtn.addEventListener('click', () => {
      useAlternateColorScale = !useAlternateColorScale;
      fetchHeatmap(); // Redraw with new color scheme
    });
    
    // Initial fetch and auto-refresh
    fetchHeatmap();
    const refreshInterval = setInterval(fetchHeatmap, 60000);
    
    // Resize handler
    window.addEventListener('resize', () => {
      Plotly.Plots.resize('heatmapPlot');
    });
  </script>
</body>
</html>