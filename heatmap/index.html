<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binance Order Book Heatmap (Plotly)</title>
  <!-- Include Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    /* Basic reset and dark theme */
    html, body {
      margin: 0;
      padding: 0;
      background-color: #121212;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    /* Fill the container with the Plotly plot */
    #heatmapPlot {
      width: 100%;
      height: 100%;
    }
    /* Overlay for last update time. */
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 3px;
      font-size: 14px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Plotly will use this div for the heatmap -->
    <div id="heatmapPlot"></div>
    <div id="overlay">Last update: <span id="lastUpdate">N/A</span></div>
  </div>
  
  <script>
    // Reference to the overlay text element.
    const overlayLastUpdate = document.getElementById('lastUpdate');
    
    // Fetch and update our Plotly heatmap.
    async function fetchHeatmap() {
      try {
        const response = await fetch('https://eldritch.gleeze.com:3500/api/orderbook/heatmap');
        const data = await response.json();
        overlayLastUpdate.textContent = new Date().toLocaleTimeString();
        drawHeatmap(data);
      } catch (error) {
        console.error('Error fetching heatmap data:', error);
      }
    }
    
    function drawHeatmap(data) {
      if (!data || !data.times || data.times.length === 0) {
        document.getElementById('heatmapPlot').innerHTML =
          '<div style="color:#fff;font-size:20px;padding:20px;">No heatmap data available</div>';
        return;
      }
      
      // Unpack the API data.
      // times: array of tick timestamps.
      // buckets: array of price bucket boundaries.
      // bidHeat and askHeat: 2D arrays where each row corresponds to a tick.
      const times = data.times;
      const buckets = data.buckets;
      const bidHeat = data.bidHeat;
      const askHeat = data.askHeat;
      
      const numTicks = times.length;
      const numBuckets = buckets.length;
      
      // Calculate the global maximum volume for normalization.
      let maxVolume = 0;
      for (let i = 0; i < numTicks; i++) {
        for (let j = 0; j < numBuckets; j++) {
          const bid = (bidHeat[i] && bidHeat[i][j]) ? bidHeat[i][j] : 0;
          const ask = (askHeat[i] && askHeat[i][j]) ? askHeat[i][j] : 0;
          const vol = bid + ask;
          if (vol > maxVolume) maxVolume = vol;
        }
      }
      // avoid division by zero
      if (maxVolume === 0) maxVolume = 1;
      
      // We want the highest price at the top. Plotly's heatmap expects z[row][col]
      // where y is the row label. So we create matrices by "flipping" the buckets.
      const totalMatrix = []; // for overall intensity
      const diffMatrix = [];  // for imbalance (ask minus bid)
      const hoverText = [];   // custom hover string for each cell
      
      // Prepare y-axis labels (price) in reversed order.
      const yLabels = [];
      for (let r = 0; r < numBuckets; r++) {
        // bucketIndex: from highest (numBuckets-1) to lowest (0)
        const bucketIndex = numBuckets - 1 - r;
        yLabels.push(Number(buckets[bucketIndex]).toFixed(4));
        totalMatrix[r] = [];
        diffMatrix[r] = [];
        hoverText[r] = [];
        for (let i = 0; i < numTicks; i++) {
          const bid = (bidHeat[i] && bidHeat[i][bucketIndex]) ? bidHeat[i][bucketIndex] : 0;
          const ask = (askHeat[i] && askHeat[i][bucketIndex]) ? askHeat[i][bucketIndex] : 0;
          // Use a square-root scale for normalization (helps with visualization).
          const I_bid = Math.sqrt(bid / maxVolume);
          const I_ask = Math.sqrt(ask / maxVolume);
          // Total intensity: higher values mean more orders
          totalMatrix[r][i] = I_bid + I_ask;  // Range: 0 to 2.
          // Imbalance: positive if asks dominate; negative if bids dominate.
          diffMatrix[r][i] = I_ask - I_bid;   // Range: -1 to 1.
      
          hoverText[r][i] = 
            `Time: ${new Date(times[i]).toLocaleTimeString()}<br>` +
            `Price: ${Number(buckets[bucketIndex]).toFixed(4)}<br>` +
            `Bid: ${bid}<br>` +
            `Ask: ${ask}`;
        }
      }
      
      // We'll build the Plotly figure using two overlaid heatmap traces.
      // Trace 1 (bottom): Shows overall intensity in a grayscale.
      const traceTotal = {
        z: totalMatrix,
        x: times,
        y: yLabels,
        type: 'heatmap',
        colorscale: [
          [0, 'rgb(0,0,0)'],
          [0.5, 'rgb(128,128,128)'],
          [1, 'rgb(255,255,255)']
        ],
        // Since intensity can be between 0 and 2, set zmax accordingly.
        zmin: 0,
        zmax: 2,
        showscale: false,
        // Let the top layer handle hover.
        hoverinfo: 'skip'
      };
      
      // Trace 2 (top): Shows the imbalance with a diverging (red–purple–blue) colorscale.
      // When ask and bid are equal (diff = 0) the color is a purple tint.
      const traceDiff = {
        z: diffMatrix,
        x: times,
        y: yLabels,
        type: 'heatmap',
        colorscale: [
          [0, 'rgb(0,0,255)'],      // Blue: bid-dominant.
          [0.5, 'rgb(128,0,128)'],  // Purple: balanced orders.
          [1, 'rgb(255,0,0)']       // Red: ask-dominant.
        ],
        zmin: -1,
        zmax: 1,
        opacity: 0.7,
        showscale: false,
        text: hoverText,
        hoverinfo: 'text'
      };
      
      const layout = {
        margin: { l: 50, r: 10, t: 30, b: 50 },
        paper_bgcolor: '#121212',
        plot_bgcolor: '#121212',
        xaxis: {
          title: 'Time',
          type: 'category', 
          tickangle: -45,
          tickfont: { color: '#fff' },
          titlefont: { color: '#fff' },
          gridcolor: '#333'
        },
        yaxis: {
          title: 'Price',
          tickfont: { color: '#fff' },
          titlefont: { color: '#fff' },
          gridcolor: '#333'
        }
      };
      
      Plotly.newPlot('heatmapPlot', [traceTotal, traceDiff], layout, {responsive: true});
    }
    
    // Perform the initial fetch and set up auto-refresh every 5 seconds.
    fetchHeatmap();
    setInterval(fetchHeatmap, 5000);
    
    // Resize the Plotly plot when the window is resized.
    window.addEventListener('resize', () => {
      const plotDiv = document.getElementById('heatmapPlot');
      Plotly.Plots.resize(plotDiv);
    });
  </script>
</body>
</html>