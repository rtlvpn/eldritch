<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binance Order Book Heatmap (Bookmap Style)</title>
  <!-- Include Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    /* Basic reset and dark theme */
    html, body {
      margin: 0;
      padding: 0;
      background-color: #0a0a0a;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    /* Fill the container with the Plotly plot */
    #heatmapPlot {
      width: 100%;
      height: 100%;
    }
    /* Overlay for last update time. */
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    /* Control panel */
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    button {
      background: #333;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      border-radius: 3px;
      cursor: pointer;
    }
    button:hover {
      background: #555;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Plotly will use this div for the heatmap -->
    <div id="heatmapPlot"></div>
    <div id="overlay">
      Last update: <span id="lastUpdate">N/A</span><br>
      Current price: <span id="currentPrice">N/A</span>
    </div>
    <div id="controls">
      <button id="resetZoom">Reset View</button>
      <button id="toggleColorScale">Toggle Colorscale</button>
    </div>
  </div>
  
  <script>
    // References to DOM elements
    const overlayLastUpdate = document.getElementById('lastUpdate');
    const currentPriceElement = document.getElementById('currentPrice');
    const resetZoomBtn = document.getElementById('resetZoom');
    const toggleColorScaleBtn = document.getElementById('toggleColorScale');
    
    // Global state
    let useAlternateColorScale = false;
    let currentLayout = {};
    let priceData = [];
    let lastPrice = null;
    let globalData = null;
    
    // Color schemes (Bookmap-inspired)
    const colorSchemes = {
      default: {
        bid: [
          [0, 'rgba(0,0,0,0)'],       // Transparent for no data
          [0.001, 'rgba(0,70,150,0.6)'],  // Low volume
          [0.5, 'rgba(0,120,200,0.75)'],  // Medium volume
          [1, 'rgba(30,180,255,0.9)']     // High volume
        ],
        ask: [
          [0, 'rgba(0,0,0,0)'],       // Transparent for no data
          [0.001, 'rgba(150,0,50,0.6)'],  // Low volume
          [0.5, 'rgba(200,0,80,0.75)'],  // Medium volume
          [1, 'rgba(255,30,100,0.9)']     // High volume
        ],
        price: '#00f9a9'  // Bright cyan for price line
      },
      alternate: {
        bid: [
          [0, 'rgba(0,0,0,0)'],       // Transparent for no data
          [0.001, 'rgba(0,80,100,0.6)'],  // Low volume
          [0.5, 'rgba(0,150,150,0.75)'],  // Medium volume
          [1, 'rgba(0,220,220,0.9)']     // High volume
        ],
        ask: [
          [0, 'rgba(0,0,0,0)'],       // Transparent for no data
          [0.001, 'rgba(100,0,100,0.6)'],  // Low volume
          [0.5, 'rgba(150,0,150,0.75)'],  // Medium volume
          [1, 'rgba(220,0,220,0.9)']     // High volume
        ],
        price: '#80ff40'  // Neon green for price line
      }
    };
    
    // Format time for display
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const seconds = date.getSeconds().toString().padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    }
    
    // Fetch data and update visualization
    async function fetchData() {
      try {
        // Get heatmap data
        const heatmapResponse = await fetch('https://eldritch.gleeze.com:3500/api/orderbook/heatmap');
        const heatmapData = await heatmapResponse.json();
        
        // Get price tick data
        const ticksResponse = await fetch('https://eldritch.gleeze.com:3500/api/orderbook/ticks');
        const ticksData = await ticksResponse.json();
        
        // Update the last update time
        overlayLastUpdate.textContent = new Date().toLocaleTimeString();
        
        // Process price data
        priceData = ticksData
          .map(tick => ({
            timestamp: tick.timestamp,
            price: tick.price
          }))
          .filter(item => item.price !== null);
        
        // Update the current price display
        if (priceData.length > 0) {
          lastPrice = priceData[priceData.length - 1].price;
          currentPriceElement.textContent = lastPrice.toFixed(2);
        }
        
        // Save data globally and draw visualization
        globalData = heatmapData;
        drawBookmapStyle(heatmapData);
        
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    }
    
    // Draw Bookmap-style visualization
    function drawBookmapStyle(data) {
      if (!data || !data.times || data.times.length === 0) {
        document.getElementById('heatmapPlot').innerHTML = 
          '<div style="color:#fff;font-size:20px;padding:20px;">No data available</div>';
        return;
      }
      
      const times = data.times;
      const buckets = data.buckets.map(b => Number(b));
      const bidHeat = data.bidHeat;
      const askHeat = data.askHeat;
      
      const numTicks = times.length;
      const numBuckets = buckets.length;
      
      // Format time labels
      const xLabels = times.map(formatTime);
      
      // Calculate price precision
      let priceDecimals = 2;
      if (buckets[0] < 100) priceDecimals = 3;
      if (buckets[0] < 10) priceDecimals = 4;
      
      // Find max volume for normalization
      let maxBidVolume = 0;
      let maxAskVolume = 0;
      
      for (let i = 0; i < numTicks; i++) {
        for (let j = 0; j < numBuckets; j++) {
          const bid = (bidHeat[i] && bidHeat[i][j]) ? bidHeat[i][j] : 0;
          const ask = (askHeat[i] && askHeat[i][j]) ? askHeat[i][j] : 0;
          
          if (bid > maxBidVolume) maxBidVolume = bid;
          if (ask > maxAskVolume) maxAskVolume = ask;
        }
      }
      
      // Prevent division by zero
      if (maxBidVolume === 0) maxBidVolume = 1;
      if (maxAskVolume === 0) maxAskVolume = 1;
      
      // Create heatmap matrices - properly positioned for price y-axis
      // For Bookmap style, we need separate bid and ask heatmaps
      const bidMatrix = Array(numBuckets).fill().map(() => Array(numTicks).fill(null));
      const askMatrix = Array(numBuckets).fill().map(() => Array(numTicks).fill(null));
      const hoverText = Array(numBuckets).fill().map(() => Array(numTicks).fill(''));
      
      // Fill the matrices - we want highest price at the top
      for (let i = 0; i < numTicks; i++) {
        for (let j = 0; j < numBuckets; j++) {
          // Get the volume data
          const bid = (bidHeat[i] && bidHeat[i][j]) ? bidHeat[i][j] : 0;
          const ask = (askHeat[i] && askHeat[i][j]) ? askHeat[i][j] : 0;
          
          // Normalize and apply non-linear scaling for better visualization
          // Using a power scale (1/3) to make smaller values more visible
          const bidValue = Math.pow(bid / maxBidVolume, 1/3);
          const askValue = Math.pow(ask / maxAskVolume, 1/3);
          
          // The matrix rows are inverted (0 is top, numBuckets-1 is bottom)
          // So we need to invert the bucket index
          const rowIndex = numBuckets - 1 - j;
          
          // Store values in matrices
          bidMatrix[rowIndex][i] = bid > 0 ? bidValue : null;
          askMatrix[rowIndex][i] = ask > 0 ? askValue : null;
          
          // Create hover text
          const price = buckets[j].toFixed(priceDecimals);
          hoverText[rowIndex][i] = 
            `<b>Time:</b> ${formatTime(times[i])}<br>` +
            `<b>Price:</b> ${price}<br>` +
            `<b>Bid Volume:</b> ${bid.toLocaleString()}<br>` +
            `<b>Ask Volume:</b> ${ask.toLocaleString()}`;
        }
      }
      
      // Create price line data
      const priceLine = {
        x: [],
        y: [],
        type: 'scatter',
        mode: 'lines',
        line: {
          color: useAlternateColorScale ? colorSchemes.alternate.price : colorSchemes.default.price,
          width: 2,
        },
        name: 'Price',
        hoverinfo: 'y+name',
        showlegend: false
      };
      
      // Match price data with time labels
      if (priceData.length > 0) {
        const timeMap = new Map(times.map((time, i) => [time, i]));
        
        for (const point of priceData) {
          if (timeMap.has(point.timestamp)) {
            const index = timeMap.get(point.timestamp);
            priceLine.x.push(xLabels[index]);
            priceLine.y.push(point.price);
          }
        }
      }
      
      // Get color schemes
      const colors = useAlternateColorScale ? colorSchemes.alternate : colorSchemes.default;
      
      // Create traces
      const bidTrace = {
        z: bidMatrix,
        x: xLabels,
        y: buckets.slice().reverse(), // Reverse to have highest price at top
        type: 'heatmap',
        colorscale: colors.bid,
        showscale: false,
        hoverinfo: 'text',
        text: hoverText,
        zsmooth: 'best',
        connectgaps: false
      };
      
      const askTrace = {
        z: askMatrix,
        x: xLabels,
        y: buckets.slice().reverse(), // Reverse to have highest price at top
        type: 'heatmap',
        colorscale: colors.ask,
        showscale: false,
        hoverinfo: 'text',
        text: hoverText,
        zsmooth: 'best',
        connectgaps: false
      };
      
      // Calculate y-axis range
      let minPrice = Math.min(...buckets);
      let maxPrice = Math.max(...buckets);
      
      // Also consider price line data
      if (priceLine.y.length > 0) {
        const minPriceData = Math.min(...priceLine.y);
        const maxPriceData = Math.max(...priceLine.y);
        minPrice = Math.min(minPrice, minPriceData);
        maxPrice = Math.max(maxPrice, maxPriceData);
      }
      
      // Add a small buffer (5%)
      const priceRange = maxPrice - minPrice;
      const buffer = priceRange * 0.05;
      minPrice = minPrice - buffer;
      maxPrice = maxPrice + buffer;
      
      // Layout configuration
      currentLayout = {
        margin: { l: 60, r: 20, t: 30, b: 60 },
        paper_bgcolor: '#0a0a0a',
        plot_bgcolor: '#0a0a0a',
        xaxis: {
          title: 'Time',
          tickangle: -45,
          tickfont: { size: 10, color: '#ddd' },
          titlefont: { color: '#fff', size: 14 },
          gridcolor: '#222',
          zeroline: false,
          nticks: 10
        },
        yaxis: {
          title: 'Price',
          tickfont: { size: 11, color: '#ddd' },
          titlefont: { color: '#fff', size: 14 },
          gridcolor: '#222',
          zeroline: false,
          range: [minPrice, maxPrice],
          autorange: false
        },
        dragmode: 'zoom',
        modebar: {
          orientation: 'v',
          bgcolor: 'rgba(0,0,0,0.7)',
          color: '#fff',
          activecolor: '#80ccff'
        },
        hovermode: 'closest',
        shapes: []
      };
      
      // Add a reference line at the last price
      if (lastPrice !== null) {
        currentLayout.shapes.push({
          type: 'line',
          x0: 0,
          x1: 1,
          y0: lastPrice,
          y1: lastPrice,
          xref: 'paper',
          yref: 'y',
          line: {
            color: 'rgba(255, 255, 255, 0.3)',
            width: 1,
            dash: 'dot'
          }
        });
      }
      
      // Plot configuration
      const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToAdd: [
          'zoom2d',
          'pan2d',
          'zoomIn2d',
          'zoomOut2d',
          'autoScale2d',
          'resetScale2d'
        ],
        modeBarButtonsToRemove: ['toImage', 'sendDataToCloud'],
        displaylogo: false,
        scrollZoom: true
      };
      
      Plotly.newPlot('heatmapPlot', [bidTrace, askTrace, priceLine], currentLayout, config);
    }
    
    // Event handlers for controls
    resetZoomBtn.addEventListener('click', () => {
      if (globalData) {
        drawBookmapStyle(globalData);
      } else {
        Plotly.relayout('heatmapPlot', {
          'xaxis.autorange': true,
          'yaxis.autorange': true
        });
      }
    });
    
    toggleColorScaleBtn.addEventListener('click', () => {
      useAlternateColorScale = !useAlternateColorScale;
      if (globalData) {
        drawBookmapStyle(globalData);
      }
    });
    
    // Initial fetch and auto-refresh
    fetchData();
    const refreshInterval = setInterval(fetchData, 60000);
    
    // Resize handler
    window.addEventListener('resize', () => {
      Plotly.Plots.resize('heatmapPlot');
    });
  </script>
</body>
</html>