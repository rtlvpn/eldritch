<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Bookmap-Style Order Book Visualization</title>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background-color: #000;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    #chart {
      width: 100%;
      height: 100%;
    }
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
    }
    button {
      background: #333;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      border-radius: 3px;
      cursor: pointer;
    }
    button:hover {
      background: #444;
    }
  </style>
</head>
<body>
  <div id="container">
    <div id="chart"></div>
    <div id="overlay">
      Last update: <span id="lastUpdate">N/A</span><br>
      Price: <span id="currentPrice">N/A</span>
    </div>
    <div id="controls">
      <button id="resetZoom">Reset View</button>
      <button id="refreshData">Refresh</button>
    </div>
  </div>

  <script>
    // DOM references
    const chart = document.getElementById('chart');
    const lastUpdateEl = document.getElementById('lastUpdate');
    const currentPriceEl = document.getElementById('currentPrice');
    const resetZoomBtn = document.getElementById('resetZoom');
    const refreshBtn = document.getElementById('refreshData');
    
    // Global state
    let globalData = null;
    let priceData = [];
    let lastPrice = null;
    let yRange = null;
    
    // Format time for display
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleTimeString();
    }
    
    // Format timestamp for x-axis
    function formatTimeAxis(timestamp) {
      const date = new Date(timestamp);
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const seconds = date.getSeconds().toString().padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    }

    // Create candlestick data from price ticks
    function createCandlesticks(priceTicks, timeInterval = 60000) { // 1 minute by default
      if (!priceTicks || priceTicks.length < 2) return [];
      
      // Sort by timestamp
      const sortedTicks = [...priceTicks].sort((a, b) => a.timestamp - b.timestamp);
      
      const candles = [];
      let currentCandle = null;
      let startTime = Math.floor(sortedTicks[0].timestamp / timeInterval) * timeInterval;
      
      for (const tick of sortedTicks) {
        const tickTime = tick.timestamp;
        const tickPrice = tick.price;
        
        // If this tick belongs to a new candle
        if (tickTime >= startTime + timeInterval) {
          // Complete the current candle if it exists
          if (currentCandle) {
            candles.push(currentCandle);
          }
          
          // Start a new candle
          startTime = Math.floor(tickTime / timeInterval) * timeInterval;
          currentCandle = {
            time: startTime,
            open: tickPrice,
            high: tickPrice,
            low: tickPrice,
            close: tickPrice
          };
        } 
        // Update the current candle
        else if (currentCandle) {
          currentCandle.high = Math.max(currentCandle.high, tickPrice);
          currentCandle.low = Math.min(currentCandle.low, tickPrice);
          currentCandle.close = tickPrice;
        } 
        // First tick in this interval
        else {
          currentCandle = {
            time: startTime,
            open: tickPrice,
            high: tickPrice,
            low: tickPrice,
            close: tickPrice
          };
        }
      }
      
      // Add the last candle
      if (currentCandle) {
        candles.push(currentCandle);
      }
      
      return candles;
    }
    
    // Fetch data from API
    async function fetchData() {
      try {
        // Get order book heatmap data
        const heatmapResponse = await fetch('https://eldritch.gleeze.com:3500/api/orderbook/heatmap');
        const heatmapData = await heatmapResponse.json();
        
        // Get price tick data
        const ticksResponse = await fetch('https://eldritch.gleeze.com:3500/api/orderbook/ticks');
        const ticksData = await ticksResponse.json();
        
        // Update the last update time
        lastUpdateEl.textContent = new Date().toLocaleTimeString();
        
        // Process price data
        priceData = ticksData.filter(tick => tick.price !== null);
        
        // Update the current price display
        if (priceData.length > 0) {
          lastPrice = priceData[priceData.length - 1].price;
          currentPriceEl.textContent = lastPrice.toFixed(2);
        }
        
        // Save data and draw visualization
        globalData = heatmapData;
        drawBookmap(heatmapData, priceData);
        
      } catch (error) {
        console.error('Error fetching data:', error);
      }
    }
    
    // Draw the Bookmap style visualization
    function drawBookmap(data, priceTicks) {
      if (!data || !data.times || data.times.length === 0) {
        chart.innerHTML = '<div style="padding:20px;color:white">No data available</div>';
        return;
      }
      
      // Extract data
      const times = data.times;
      const buckets = data.buckets.map(b => Number(b));
      const bidHeat = data.bidHeat;
      const askHeat = data.askHeat;
      
      // Format time labels for x-axis
      const xLabels = times.map(formatTimeAxis);
      
      // Create combined depth heatmap data
      const depthData = [];
      let maxValue = 0;
      
      for (let t = 0; t < times.length; t++) {
        for (let p = 0; p < buckets.length; p++) {
          const price = buckets[p];
          const time = times[t];
          const bidVol = (bidHeat[t] && bidHeat[t][p]) ? bidHeat[t][p] : 0;
          const askVol = (askHeat[t] && askHeat[t][p]) ? askHeat[t][p] : 0;
          
          // Combine into a single intensity value with sign
          // Positive for bids, negative for asks
          const value = bidVol > 0 ? bidVol : -askVol;
          maxValue = Math.max(maxValue, Math.abs(value));
          
          if (bidVol > 0 || askVol > 0) {
            depthData.push({
              x: xLabels[t],
              y: price,
              z: Math.abs(value),
              side: value > 0 ? 'bid' : 'ask',
              timeIdx: t,
              priceIdx: p,
              bidVol,
              askVol
            });
          }
        }
      }

      // Create candlestick chart data
      const candles = createCandlesticks(priceTicks);
      const candleTrace = {
        x: candles.map(c => formatTimeAxis(c.time)),
        open: candles.map(c => c.open),
        high: candles.map(c => c.high),
        low: candles.map(c => c.low),
        close: candles.map(c => c.close),
        type: 'candlestick',
        increasing: {
          line: { color: '#26a69a', width: 1.5 },
          fillcolor: 'rgba(38, 166, 154, 0.7)'
        },
        decreasing: {
          line: { color: '#ef5350', width: 1.5 },
          fillcolor: 'rgba(239, 83, 80, 0.7)'
        },
        line: { width: 1 },
        opacity: 0.8,
        yaxis: 'y',
        name: 'Price'
      };
      
      // Create bid and ask heatmap data
      const bidPoints = depthData.filter(p => p.side === 'bid');
      const askPoints = depthData.filter(p => p.side === 'ask');
      
      // Normalize values using logarithmic scale for better visualization
      function normalize(val) {
        return val > 0 ? Math.log(val + 1) / Math.log(maxValue + 1) : 0;
      }
      
      // Create custom heatmap scatter plots for bids and asks
      const bidScatter = {
        x: bidPoints.map(p => p.x),
        y: bidPoints.map(p => p.y),
        mode: 'markers',
        marker: {
          size: 10,
          opacity: 0.9,
          color: bidPoints.map(p => normalize(p.z)),
          colorscale: [
            [0, 'rgba(0,30,80,0.1)'],
            [0.2, 'rgba(0,70,150,0.5)'],
            [0.5, 'rgba(30,110,200,0.7)'],
            [0.8, 'rgba(50,150,230,0.85)'],
            [1, 'rgba(70,200,255,0.95)']
          ],
          symbol: 'square',
          line: {width: 0}
        },
        hoverinfo: 'text',
        text: bidPoints.map(p => 
          `Time: ${formatTime(times[p.timeIdx])}<br>` +
          `Price: ${p.y.toFixed(2)}<br>` +
          `Bid Volume: ${p.bidVol.toLocaleString()}`
        ),
        name: 'Bid Depth',
        showlegend: false
      };
      
      const askScatter = {
        x: askPoints.map(p => p.x),
        y: askPoints.map(p => p.y),
        mode: 'markers',
        marker: {
          size: 10,
          opacity: 0.9,
          color: askPoints.map(p => normalize(p.z)),
          colorscale: [
            [0, 'rgba(80,0,30,0.1)'],
            [0.2, 'rgba(150,0,70,0.5)'],
            [0.5, 'rgba(200,30,100,0.7)'],
            [0.8, 'rgba(230,50,130,0.85)'],
            [1, 'rgba(255,70,150,0.95)']
          ],
          symbol: 'square',
          line: {width: 0}
        },
        hoverinfo: 'text',
        text: askPoints.map(p => 
          `Time: ${formatTime(times[p.timeIdx])}<br>` +
          `Price: ${p.y.toFixed(2)}<br>` +
          `Ask Volume: ${p.askVol.toLocaleString()}`
        ),
        name: 'Ask Depth',
        showlegend: false
      };
      
      // Create simple price line for reference
      const priceLine = {
        x: priceTicks.map(p => formatTimeAxis(p.timestamp)),
        y: priceTicks.map(p => p.price),
        type: 'scatter',
        mode: 'lines',
        line: {
          color: 'rgba(255,255,255,0.6)',
          width: 1,
          dash: 'dot'
        },
        name: 'Price',
        hoverinfo: 'none',
        showlegend: false
      };
      
      // Calculate y-axis range
      let minPrice = Math.min(...buckets);
      let maxPrice = Math.max(...buckets);
      
      // Include candle price ranges
      if (candles.length > 0) {
        const minCandlePrice = Math.min(...candles.map(c => c.low));
        const maxCandlePrice = Math.max(...candles.map(c => c.high));
        minPrice = Math.min(minPrice, minCandlePrice);
        maxPrice = Math.max(maxPrice, maxCandlePrice);
      }
      
      // Add buffer (5%)
      const priceRange = maxPrice - minPrice;
      const buffer = priceRange * 0.05;
      minPrice -= buffer;
      maxPrice += buffer;
      
      // Save for zoom reset
      yRange = [minPrice, maxPrice];
      
      // Layout configuration
      const layout = {
        plot_bgcolor: '#000',
        paper_bgcolor: '#000',
        margin: { l: 60, r: 40, t: 30, b: 60 },
        xaxis: {
          title: 'Time',
          tickfont: { size: 10, color: '#aaa' },
          gridcolor: '#222',
          tickangle: -45
        },
        yaxis: {
          title: 'Price',
          tickfont: { size: 11, color: '#aaa' },
          gridcolor: '#222',
          range: yRange
        },
        dragmode: 'zoom',
        showlegend: false,
        hovermode: 'closest'
      };
      
      // Create the plot
      const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToRemove: ['sendDataToCloud', 'autoScale2d', 'lasso2d', 'select2d'],
        modeBarButtonsToAdd: ['zoom2d', 'pan2d', 'resetScale2d'],
        displaylogo: false,
        scrollZoom: true
      };
      
      Plotly.newPlot('chart', [bidScatter, askScatter, candleTrace, priceLine], layout, config);
    }
    
    // Event listeners for controls
    resetZoomBtn.addEventListener('click', () => {
      if (yRange) {
        Plotly.relayout('chart', {
          'yaxis.range': yRange,
          'xaxis.autorange': true
        });
      }
    });
    
    refreshBtn.addEventListener('click', fetchData);
    
    // Initial fetch and auto-refresh timer
    fetchData();
    const refreshInterval = setInterval(fetchData, 60000);  // Refresh every minute
    
    // Handle window resize
    window.addEventListener('resize', () => {
      Plotly.Plots.resize('chart');
    });
  </script>
</body>
</html>