<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Binance Order Book Heatmap (Plotly)</title>
  <!-- Include Plotly.js -->
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  <style>
    /* Basic reset and dark theme */
    html, body {
      margin: 0;
      padding: 0;
      background-color: #0a0a0a;
      color: #fff;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    /* Fill the container with the Plotly plot */
    #heatmapPlot {
      width: 100%;
      height: 100%;
    }
    /* Overlay for last update time. */
    #overlay {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    /* Control panel */
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0, 0, 0, 0.7);
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 10;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    button {
      background: #333;
      color: white;
      border: none;
      padding: 5px 10px;
      margin: 2px;
      border-radius: 3px;
      cursor: pointer;
    }
    button:hover {
      background: #555;
    }
  </style>
</head>
<body>
  <div id="container">
    <!-- Plotly will use this div for the heatmap -->
    <div id="heatmapPlot"></div>
    <div id="overlay">
      Last update: <span id="lastUpdate">N/A</span><br>
      Current price: <span id="currentPrice">N/A</span>
    </div>
    <div id="controls">
      <button id="resetZoom">Reset View</button>
      <button id="toggleColorScale">Toggle Colorscale</button>
    </div>
  </div>
  
  <script>
    // References to DOM elements
    const overlayLastUpdate = document.getElementById('lastUpdate');
    const currentPriceElement = document.getElementById('currentPrice');
    const resetZoomBtn = document.getElementById('resetZoom');
    const toggleColorScaleBtn = document.getElementById('toggleColorScale');
    
    // Global state
    let useAlternateColorScale = false;
    let currentLayout = {};
    let priceData = [];
    let lastPrice = null;
    
    // Cyberpunk-inspired color schemes with neon glow effect
    const colorSchemes = {
      default: {
        intensity: [
          [0, 'rgb(2,3,8)'],          // Deep black for background
          [0.2, 'rgb(10,12,25)'],     // Very dark indigo for low areas
          [0.4, 'rgb(25,20,50)'],     // Deep violet for medium areas
          [0.6, 'rgb(40,25,80)'],     // Purple for rising areas
          [0.8, 'rgb(60,40,120)'],    // Bright purple for high areas
          [0.9, 'rgb(100,80,160)'],   // Neon purple for peaks
          [1, 'rgb(140,120,210)']     // Glowing violet highlight for highest points
        ],
        imbalance: [
          [0, 'rgb(0,80,255)'],       // Neon blue for strong bid
          [0.25, 'rgb(30,120,210)'],  // Bright cyan-blue for moderate bid
          [0.4, 'rgb(20,180,180)'],   // Teal for slight bid
          [0.5, 'rgb(70,30,100)'],    // Deep purple for neutral
          [0.6, 'rgb(180,50,150)'],   // Magenta for slight ask
          [0.75, 'rgb(255,50,120)'],  // Hot pink for moderate ask
          [1, 'rgb(255,30,60)']       // Neon red for strong ask
        ]
      },
      alternate: {
        intensity: [
          [0, 'rgb(1,5,10)'],          // Nearly black background
          [0.2, 'rgb(5,15,30)'],       // Deep cyan-black
          [0.4, 'rgb(10,35,60)'],      // Dark teal-blue
          [0.6, 'rgb(20,80,100)'],     // Medium teal
          [0.8, 'rgb(0,130,140)'],     // Bright teal
          [0.9, 'rgb(0,180,200)'],     // Neon teal
          [1, 'rgb(60,230,255)']       // Glowing cyan highlight
        ],
        imbalance: [
          [0, 'rgb(0,100,220)'],       // Neon blue for strong bid
          [0.25, 'rgb(20,150,255)'],   // Bright blue for moderate bid
          [0.4, 'rgb(0,210,210)'],     // Cyan for slight bid
          [0.5, 'rgb(20,20,35)'],      // Very dark neutral
          [0.6, 'rgb(120,20,120)'],    // Deep magenta for slight ask
          [0.75, 'rgb(200,0,150)'],    // Vivid magenta for moderate ask
          [1, 'rgb(255,0,100)']        // Neon pink for strong ask
        ]
      }
    };
    
    // Fetch and update our Plotly heatmap.
    async function fetchHeatmap() {
      try {
        const response = await fetch('https://eldritch.gleeze.com:3500/api/orderbook/heatmap');
        const data = await response.json();
        overlayLastUpdate.textContent = new Date().toLocaleTimeString();
        
        // Also fetch the price data
        await fetchPriceData();
        
        drawHeatmap(data);
      } catch (error) {
        console.error('Error fetching heatmap data:', error);
      }
    }
    
    // Fetch price data from the ticks endpoint
    async function fetchPriceData() {
      try {
        const response = await fetch('https://eldritch.gleeze.com:3500/api/orderbook/ticks');
        const data = await response.json();
        
        // Extract timestamps and prices
        priceData = data.map(tick => ({
          timestamp: tick.timestamp,
          price: tick.price
        })).filter(item => item.price !== null);
        
        // Update the current price display if we have price data
        if (priceData.length > 0) {
          lastPrice = priceData[priceData.length - 1].price;
          currentPriceElement.textContent = lastPrice.toFixed(2);
        }
      } catch (error) {
        console.error('Error fetching price data:', error);
      }
    }
    
    function formatTime(timestamp) {
      const date = new Date(timestamp);
      const hours = date.getHours().toString().padStart(2, '0');
      const minutes = date.getMinutes().toString().padStart(2, '0');
      const seconds = date.getSeconds().toString().padStart(2, '0');
      return `${hours}:${minutes}:${seconds}`;
    }
    
    function drawHeatmap(data) {
      if (!data || !data.times || data.times.length === 0) {
        document.getElementById('heatmapPlot').innerHTML =
          '<div style="color:#fff;font-size:20px;padding:20px;">No heatmap data available</div>';
        return;
      }
      
      // Unpack the API data.
      const times = data.times;
      const buckets = data.buckets;
      const bidHeat = data.bidHeat;
      const askHeat = data.askHeat;
      
      const numTicks = times.length;
      const numBuckets = buckets.length;
      
      // Format x-axis labels (time)
      const xLabels = times.map(formatTime);
      
      // Calculate the global maximum volume for normalization.
      let maxVolume = 0;
      for (let i = 0; i < numTicks; i++) {
        for (let j = 0; j < numBuckets; j++) {
          const bid = (bidHeat[i] && bidHeat[i][j]) ? bidHeat[i][j] : 0;
          const ask = (askHeat[i] && askHeat[i][j]) ? askHeat[i][j] : 0;
          const vol = bid + ask;
          if (vol > maxVolume) maxVolume = vol;
        }
      }
      if (maxVolume === 0) maxVolume = 1;
      
      // We want the highest price at the top
      const bidMatrix = [];  // Separate matrix for bids only
      const askMatrix = [];  // Separate matrix for asks only
      const hoverText = [];
      
      // Prepare y-axis labels (price) in reversed order.
      const yLabels = [];
      
      // Calculate the price format precision based on the values
      let priceDecimals = 4;
      const firstPrice = Number(buckets[0]);
      if (firstPrice >= 1000) priceDecimals = 2;
      else if (firstPrice >= 100) priceDecimals = 3;
      
      for (let r = 0; r < numBuckets; r++) {
        const bucketIndex = numBuckets - 1 - r;
        // Format the price for the label with dynamic precision
        yLabels.push(Number(buckets[bucketIndex]).toFixed(priceDecimals));
        
        bidMatrix[r] = [];
        askMatrix[r] = [];
        hoverText[r] = [];
        
        for (let i = 0; i < numTicks; i++) {
          const bid = (bidHeat[i] && bidHeat[i][bucketIndex]) ? bidHeat[i][bucketIndex] : 0;
          const ask = (askHeat[i] && askHeat[i][bucketIndex]) ? askHeat[i][bucketIndex] : 0;
          
          // Use a cube-root scale for better visual dynamics with large volume variations
          const I_bid = Math.cbrt(bid / maxVolume);
          const I_ask = Math.cbrt(ask / maxVolume);
          
          // Separate bid and ask matrices for Bookmap style
          bidMatrix[r][i] = bid > 0 ? I_bid : null;
          askMatrix[r][i] = ask > 0 ? I_ask : null;
          
          // Enhanced hover text
          const bidColor = bid > ask ? "<span style='color:#8af'>↑</span>" : "";
          const askColor = ask > bid ? "<span style='color:#f88'>↓</span>" : "";
          
          hoverText[r][i] = 
            `<b>Time:</b> ${formatTime(times[i])}<br>` +
            `<b>Price:</b> ${Number(buckets[bucketIndex]).toFixed(priceDecimals)}<br>` +
            `<b>Bid:</b> ${bid.toLocaleString()} ${bidColor}<br>` +
            `<b>Ask:</b> ${ask.toLocaleString()} ${askColor}<br>` +
            `<b>Ratio:</b> ${bid+ask > 0 ? (bid/(bid+ask)*100).toFixed(1) + '%' : 'N/A'} bid`;
        }
      }
      
      // Get the selected color scheme
      const colorScheme = useAlternateColorScale ? colorSchemes.alternate : colorSchemes.default;
      
      // Trace 1: Bid heatmap (more Bookmap-like representation)
      const traceBid = {
        z: bidMatrix,
        x: xLabels,
        y: yLabels,
        type: 'heatmap',
        colorscale: [
          [0, 'rgba(0,0,0,0)'],  // Transparent for null values
          [0.001, 'rgba(0,100,200,0.7)'],  // Start color for very low values
          [1, 'rgba(0,200,255,0.9)']  // End color for high values
        ],
        showscale: false,
        hoverinfo: 'text',
        text: hoverText,
        connectgaps: false,
        showlegend: false
      };
      
      // Trace 2: Ask heatmap
      const traceAsk = {
        z: askMatrix,
        x: xLabels,
        y: yLabels,
        type: 'heatmap',
        colorscale: [
          [0, 'rgba(0,0,0,0)'],  // Transparent for null values
          [0.001, 'rgba(200,0,100,0.7)'],  // Start color for very low values
          [1, 'rgba(255,50,50,0.9)']  // End color for high values
        ],
        opacity: 0.8,
        showscale: false,
        hoverinfo: 'text',
        text: hoverText,
        connectgaps: false,
        showlegend: false
      };
      
      // Trace 3: Price line with enhanced visibility
      const priceLine = {
        x: [],
        y: [],
        type: 'scatter',
        mode: 'lines',
        line: {
          color: '#00ffaa',
          width: 2.5,
          shape: 'spline',
          smoothing: 1.3
        },
        name: 'Price',
        hoverinfo: 'y+name',
        showlegend: false
      };
      
      // Add price data to the line trace if available
      if (priceData.length > 0) {
        // Match price data with time labels
        const timeMap = new Map(times.map((time, i) => [time, i]));
        
        for (const point of priceData) {
          if (timeMap.has(point.timestamp)) {
            const index = timeMap.get(point.timestamp);
            priceLine.x.push(xLabels[index]);
            priceLine.y.push(point.price);
          }
        }
      }
      
      // Calculate min and max price for setting consistent y-axis range
      let minPrice = Infinity;
      let maxPrice = -Infinity;
      
      // Get range from price data
      if (priceData.length > 0) {
        const priceValues = priceLine.y;
        const localMin = Math.min(...priceValues);
        const localMax = Math.max(...priceValues);
        if (localMin < minPrice) minPrice = localMin;
        if (localMax > maxPrice) maxPrice = localMax;
      }
      
      // Also consider bucket range
      if (buckets.length > 0) {
        const minBucket = Math.min(...buckets.map(b => Number(b)));
        const maxBucket = Math.max(...buckets.map(b => Number(b)));
        if (minBucket < minPrice) minPrice = minBucket;
        if (maxBucket > maxPrice) maxPrice = maxBucket;
      }
      
      // Add buffer (5% of price range)
      const range = maxPrice - minPrice;
      const buffer = range * 0.05;
      minPrice -= buffer;
      maxPrice += buffer;
      
      // Layout with better Bookmap-style visualization
      currentLayout = {
        margin: { l: 70, r: 20, t: 30, b: 60 },
        paper_bgcolor: '#0a0a0a',
        plot_bgcolor: '#0a0a0a',
        xaxis: {
          title: 'Time',
          tickangle: -45,
          tickfont: { size: 10, color: '#ddd' },
          titlefont: { color: '#fff', size: 14 },
          gridcolor: '#222',
          zeroline: false,
          nticks: 10
        },
        yaxis: {
          title: 'Price',
          tickfont: { size: 11, color: '#ddd' },
          titlefont: { color: '#fff', size: 14 },
          gridcolor: '#222',
          zeroline: false,
          range: [minPrice, maxPrice],
          autorange: false
        },
        shapes: [],  // We'll add a midpoint line if needed
        dragmode: 'zoom',
        modebar: {
          orientation: 'v',
          bgcolor: 'rgba(0,0,0,0.7)',
          color: '#fff',
          activecolor: '#80ccff'
        }
      };
      
      // Add a reference line at the last price
      if (lastPrice !== null) {
        currentLayout.shapes.push({
          type: 'line',
          x0: 0,
          x1: 1,
          y0: lastPrice,
          y1: lastPrice,
          xref: 'paper',
          yref: 'y',
          line: {
            color: 'rgba(255, 255, 255, 0.3)',
            width: 1,
            dash: 'dot'
          }
        });
      }
      
      // Configuration for better interactivity
      const config = {
        responsive: true,
        displayModeBar: true,
        modeBarButtonsToAdd: [
          'zoom2d',
          'pan2d',
          'zoomIn2d',
          'zoomOut2d',
          'autoScale2d',
          'resetScale2d'
        ],
        modeBarButtonsToRemove: ['toImage', 'sendDataToCloud'],
        displaylogo: false,
        scrollZoom: true
      };
      
      Plotly.newPlot('heatmapPlot', [traceBid, traceAsk, priceLine], currentLayout, config);
    }
    
    // Event handlers for controls
    resetZoomBtn.addEventListener('click', () => {
      Plotly.relayout('heatmapPlot', {
        'xaxis.autorange': true,
        'yaxis.autorange': true
      });
    });
    
    toggleColorScaleBtn.addEventListener('click', () => {
      useAlternateColorScale = !useAlternateColorScale;
      fetchHeatmap(); // Redraw with new color scheme
    });
    
    // Initial fetch and auto-refresh
    fetchHeatmap();
    const refreshInterval = setInterval(fetchHeatmap, 60000);
    
    // Resize handler
    window.addEventListener('resize', () => {
      Plotly.Plots.resize('heatmapPlot');
    });
  </script>
</body>
</html>