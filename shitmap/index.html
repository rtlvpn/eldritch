<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRXUSDT Orderbook Heatmap</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a1a;
            color: #fff;
            font-family: monospace;
            overflow: hidden;
        }
        
        #header {
            background-color: #0a0a1a;
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #333;
        }
        
        #title {
            font-weight: bold;
        }
        
        #data {
            text-align: right;
        }
        
        .price { color: #FFD700; }
        .bid { color: #0f0; }
        .ask { color: #f00; }
        .negative { color: #f00; }
        
        #status {
            position: absolute;
            left: 10px;
            top: 30px;
            color: #0f0;
            z-index: 100;
            font-size: 11px;
            background-color: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        #chart {
            position: relative;
            width: 100vw;
            height: calc(100vh - 25px);
        }
        
        #priceDisplay {
            position: absolute;
            right: 0;
            background-color: #f00;
            padding: 2px 5px;
            font-size: 12px;
            z-index: 10;
        }
        
        #timeDisplay {
            position: absolute;
            right: 60px;
            bottom: 10px;
            background-color: #f00;
            padding: 2px 5px;
            font-size: 11px;
            z-index: 10;
        }
        
        #priceAxis {
            position: absolute;
            right: 0;
            top: 0;
            width: 60px;
            height: 100%;
            color: #fff;
            text-align: right;
            font-size: 12px;
            padding-right: 5px;
            box-sizing: border-box;
            line-height: 1;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="title">TRXUSDT Orderbook Heatmap</div>
        <div id="data">
            Price: <span class="price">0.0000</span> | 
            Bid: <span class="bid">0.0000</span> | 
            Ask: <span class="ask">0.0000</span> | 
            Spread: <span id="spread">0.000000</span> | 
            Imbalance: <span id="imbalance" class="negative">0.00%</span>
        </div>
    </div>
    
    <div id="status">Connected</div>
    
    <div id="chart">
        <canvas id="heatmap"></canvas>
        <canvas id="overlay"></canvas>
        <div id="priceDisplay">0.0000</div>
        <div id="timeDisplay">00:00</div>
        <div id="priceAxis"></div>
    </div>
    
    <script>
        // Configuration
        const wsUrl = 'wss://heatmapeldritch.gleeze.com:3500';
        
        // DOM elements
        const heatmapCanvas = document.getElementById('heatmap');
        const overlayCanvas = document.getElementById('overlay');
        const priceDisplay = document.getElementById('priceDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const priceAxis = document.getElementById('priceAxis');
        const status = document.getElementById('status');
        
        // Canvas context
        const heatmapCtx = heatmapCanvas.getContext('2d');
        const overlayCtx = overlayCanvas.getContext('2d');
        
        // State
        let orderbookData = null;
        let currentPrice = null;
        
        // Resize canvases to full window
        function resizeCanvases() {
            const chart = document.getElementById('chart');
            const width = chart.clientWidth;
            const height = chart.clientHeight;
            
            heatmapCanvas.width = width;
            heatmapCanvas.height = height;
            overlayCanvas.width = width;
            overlayCanvas.height = height;
            
            if (orderbookData) {
                renderOrderbook();
            }
        }
        
        // Connect to WebSocket
        function connect() {
            const socket = new WebSocket(wsUrl);
            
            socket.onopen = () => {
                status.textContent = 'Connected';
                
                // Subscribe to orderbook data
                socket.send(JSON.stringify({
                    action: 'subscribe',
                    topics: ['orderbook']
                }));
            };
            
            socket.onclose = () => {
                status.textContent = 'Disconnected';
                setTimeout(connect, 2000);
            };
            
            socket.onerror = (err) => {
                status.textContent = 'Error';
                console.error('WebSocket error:', err);
            };
            
            socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    
                    if (message.type === 'orderbook') {
                        orderbookData = message.data;
                        updateHeader(orderbookData);
                        renderOrderbook();
                    }
                } catch (err) {
                    console.error('Error processing message', err);
                }
            };
        }
        
        // Update header with orderbook data
        function updateHeader(data) {
            if (!data || !data.metrics) return;
            
            document.querySelector('.price').textContent = data.metrics.midPrice.toFixed(4);
            document.querySelector('.bid').textContent = data.metrics.bestBid.toFixed(4);
            document.querySelector('.ask').textContent = data.metrics.bestAsk.toFixed(4);
            document.getElementById('spread').textContent = data.metrics.spread.toFixed(6);
            
            const imbalanceEl = document.getElementById('imbalance');
            const imbalanceVal = (data.metrics.imbalance * 100).toFixed(2);
            imbalanceEl.textContent = imbalanceVal + '%';
            imbalanceEl.className = data.metrics.imbalance >= 0 ? 'bid' : 'negative';
            
            currentPrice = data.metrics.midPrice;
            const now = new Date();
            timeDisplay.textContent = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
        }
        
        // Render orderbook visualization (simple bid/ask separation like your second image)
        function renderOrderbook() {
            if (!orderbookData || !currentPrice) return;
            
            const width = heatmapCanvas.width;
            const height = heatmapCanvas.height;
            const effectiveWidth = width - 60; // Account for price axis
            
            // Clear canvases
            heatmapCtx.clearRect(0, 0, width, height);
            overlayCtx.clearRect(0, 0, width, height);
            
            // Get bids and asks from orderbook
            const bids = orderbookData.bids || [];
            const asks = orderbookData.asks || [];
            
            // Calculate min/max prices to display
            // Use fixed range of +/- 20% from current price
            const range = currentPrice * 0.2;
            const minPrice = currentPrice - range;
            const maxPrice = currentPrice + range;
            
            // Calculate price to Y position conversion
            const priceToY = (price) => height * (maxPrice - price) / (maxPrice - minPrice);
            
            // Calculate the dividing line (current price)
            const currentPriceY = priceToY(currentPrice);
            
            // Fill bid zone (yellow, below current price)
            const bidGradient = heatmapCtx.createLinearGradient(0, currentPriceY, 0, height);
            bidGradient.addColorStop(0, 'rgba(255, 255, 0, 0.7)');  // Yellow at top
            bidGradient.addColorStop(1, 'rgba(200, 180, 0, 0.7)');  // Darker yellow at bottom
            
            heatmapCtx.fillStyle = bidGradient;
            heatmapCtx.fillRect(0, currentPriceY, effectiveWidth, height - currentPriceY);
            
            // Fill ask zone (blue, above current price)
            const askGradient = heatmapCtx.createLinearGradient(0, 0, 0, currentPriceY);
            askGradient.addColorStop(0, 'rgba(0, 150, 200, 0.7)');  // Cyan at top
            askGradient.addColorStop(1, 'rgba(0, 180, 240, 0.7)');  // Lighter blue at bottom
            
            heatmapCtx.fillStyle = askGradient;
            heatmapCtx.fillRect(0, 0, effectiveWidth, currentPriceY);
            
            // Draw horizontal lines for different price levels
            heatmapCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            heatmapCtx.lineWidth = 1;
            
            // Draw bid lines (more intense yellow for higher volume)
            bids.forEach(bid => {
                const price = bid.price;
                const volume = bid.volume;
                
                if (price < minPrice || price > currentPrice) return;
                
                const y = priceToY(price);
                
                // Calculate intensity based on volume (normalized to max volume in visible range)
                const maxBidVolume = Math.max(...bids.map(b => b.volume), 1);
                const intensity = Math.min(1, volume / maxBidVolume);
                
                // Only draw lines for significant orders
                if (intensity > 0.05) {
                    heatmapCtx.beginPath();
                    heatmapCtx.strokeStyle = `rgba(255, 255, 0, ${intensity * 0.7})`;
                    heatmapCtx.moveTo(0, y);
                    heatmapCtx.lineTo(effectiveWidth, y);
                    heatmapCtx.stroke();
                }
            });
            
            // Draw ask lines (more intense blue for higher volume)
            asks.forEach(ask => {
                const price = ask.price;
                const volume = ask.volume;
                
                if (price > maxPrice || price < currentPrice) return;
                
                const y = priceToY(price);
                
                // Calculate intensity based on volume (normalized to max volume in visible range)
                const maxAskVolume = Math.max(...asks.map(a => a.volume), 1);
                const intensity = Math.min(1, volume / maxAskVolume);
                
                // Only draw lines for significant orders
                if (intensity > 0.05) {
                    heatmapCtx.beginPath();
                    heatmapCtx.strokeStyle = `rgba(0, 200, 255, ${intensity * 0.7})`;
                    heatmapCtx.moveTo(0, y);
                    heatmapCtx.lineTo(effectiveWidth, y);
                    heatmapCtx.stroke();
                }
            });
            
            // Draw current price line
            overlayCtx.beginPath();
            overlayCtx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
            overlayCtx.lineWidth = 1;
            overlayCtx.setLineDash([5, 3]);
            overlayCtx.moveTo(0, currentPriceY);
            overlayCtx.lineTo(effectiveWidth, currentPriceY);
            overlayCtx.stroke();
            overlayCtx.setLineDash([]);
            
            // Update price display
            priceDisplay.style.top = (currentPriceY - 10) + 'px';
            priceDisplay.textContent = currentPrice.toFixed(4);
            
            // Update price axis
            updatePriceAxis(minPrice, maxPrice, priceToY);
        }
        
        // Update price axis with labels at appropriate intervals
        function updatePriceAxis(minPrice, maxPrice, priceToY) {
            priceAxis.innerHTML = '';
            const priceRange = maxPrice - minPrice;
            const step = calculateNiceStep(priceRange / 10);
            
 // Start at a "nice" value
            const startPrice = Math.ceil(minPrice / step) * step;
            
            for (let price = startPrice; price <= maxPrice; price += step) {
                const y = priceToY(price);
                
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.top = (y - 6) + 'px';
                label.textContent = price.toFixed(4);
                priceAxis.appendChild(label);
            }
        }
        
        // Calculate a nice step size (1, 2, 5, 10, 20, 50, etc.)
        function calculateNiceStep(roughStep) {
            const exponent = Math.floor(Math.log10(roughStep));
            const fraction = roughStep / Math.pow(10, exponent);
            
            if (fraction < 1.5) return Math.pow(10, exponent);
            if (fraction < 3.5) return 2 * Math.pow(10, exponent);
            if (fraction < 7.5) return 5 * Math.pow(10, exponent);
            return 10 * Math.pow(10, exponent);
        }
        
        // Initialize
        window.addEventListener('load', () => {
            resizeCanvases();
            connect();
            
            // Set up periodic rendering for smooth updates
            setInterval(() => {
                if (orderbookData) {
                    renderOrderbook();
                }
            }, 1000); // Update every second for better performance
        });
        
        window.addEventListener('resize', resizeCanvases);
    </script>
</body>
</html>
