<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Orderbook Heatmap</title>
    <!-- TradingView Lightweight Charts -->
    <script src="https://unpkg.com/lightweight-charts/dist/lightweight-charts.standalone.production.js"></script>
    <!-- D3.js for heatmap -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
        }
        .container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            padding: 10px;
            box-sizing: border-box;
        }
        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .symbol {
            font-size: 18px;
            font-weight: bold;
        }
        .price {
            font-size: 24px;
            font-weight: bold;
            color: #4AFA9A;
        }
        .chart-container {
            position: relative;
            flex-grow: 1;
            border: 1px solid #333;
            overflow: hidden;
        }
        #tvChart {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        #heatmapLayer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
        }
        .controls {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        button {
            background-color: #222;
            color: #fff;
            border: 1px solid #444;
            padding: 8px 12px;
            cursor: pointer;
        }
        button:hover {
            background-color: #333;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 18px;
            color: #888;
            z-index: 20;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="symbol" id="symbolDisplay">TRXUSDT</div>
            <div class="price" id="priceDisplay">---.----</div>
        </div>
        <div class="chart-container">
            <div id="tvChart"></div>
            <div id="heatmapLayer"></div>
            <div class="loading" id="loadingIndicator">Loading order book data...</div>
        </div>
        <div class="controls">
            <button id="refreshBtn">Refresh Data</button>
            <span id="lastUpdated">Last updated: --:--:--</span>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            apiBaseUrl: 'https://heatmapeldritch.gleeze.com', // Replace with your backend URL
            symbol: 'TRXUSDT',
            timeframe: '1h',
            refreshInterval: 15000,
            bucketSize: 0.00001,
            maxBuckets: 300,
            chartOptions: {
                layout: {
                    background: { color: 'rgba(0, 0, 0, 0.0)' }, // Transparent background
                    textColor: '#d1d4dc',
                },
                grid: {
                    vertLines: { color: 'rgba(42, 46, 57, 0.5)' },
                    horzLines: { color: 'rgba(42, 46, 57, 0.5)' },
                },
                timeScale: {
                    borderColor: 'rgba(197, 203, 206, 0.8)',
                    timeVisible: true,
                    secondsVisible: false,
                },
                rightPriceScale: {
                    borderColor: 'rgba(197, 203, 206, 0.8)',
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                handleScroll: true,
                handleScale: true,
            },
            candlestickOptions: {
                upColor: '#4AFA9A',
                downColor: '#FA4A83',
                borderVisible: false,
                wickUpColor: '#4AFA9A',
                wickDownColor: '#FA4A83',
            },
            heatmapColors: {
                bids: ['#002200', '#004400', '#006600', '#008800', '#00AA00', '#00FF00'],
                asks: ['#220000', '#440000', '#660000', '#880000', '#AA0000', '#FF0000'],
                neutral: '#001a1a'
            }
        };

        // State
        let state = {
            chart: null,
            candleSeries: null,
            heatmapData: null,
            currentPrice: null,
            lastUpdated: null,
            heatmapSVG: null,
            resizeObserver: null,
        };

        // Elements
        const symbolDisplay = document.getElementById('symbolDisplay');
        const priceDisplay = document.getElementById('priceDisplay');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const refreshBtn = document.getElementById('refreshBtn');
        const lastUpdatedDisplay = document.getElementById('lastUpdated');
        const chartContainer = document.getElementById('tvChart');
        const heatmapContainer = document.getElementById('heatmapLayer');

        // Initialize app
        function init() {
            symbolDisplay.textContent = CONFIG.symbol;
            
            // Initialize TradingView chart
            initChart();
            
            // Initialize D3 heatmap
            initHeatmap();
            
            // Set up resize handling
            setupResizeHandler();
            
            // Button events
            refreshBtn.addEventListener('click', fetchAllData);
            
            // Initial data load
            fetchAllData();
            
            // Set up auto refresh
            setInterval(fetchAllData, CONFIG.refreshInterval);
        }

        // Initialize TradingView Lightweight Chart
        function initChart() {
            state.chart = LightweightCharts.createChart(chartContainer, CONFIG.chartOptions);
            
            // Add candlestick series
            state.candleSeries = state.chart.addCandlestickSeries(CONFIG.candlestickOptions);
            
            // Set initial visible range (1 hour)
            const now = new Date();
            const oneHourAgo = new Date(now.getTime() - 3600 * 1000);
            
            state.chart.timeScale().setVisibleRange({
                from: oneHourAgo.getTime() / 1000,
                to: now.getTime() / 1000
            });
        }

        // Initialize D3 heatmap
        function initHeatmap() {
            state.heatmapSVG = d3.select('#heatmapLayer')
                .append('svg')
                .attr('width', '100%')
                .attr('height', '100%')
                .style('position', 'absolute')
                .style('top', 0)
                .style('left', 0);
        }

        // Set up resize handler
        function setupResizeHandler() {
            // Use ResizeObserver to handle container size changes
            state.resizeObserver = new ResizeObserver(entries => {
                for (let entry of entries) {
                    if (state.chart) {
                        state.chart.resize(
                            entry.contentRect.width, 
                            entry.contentRect.height
                        );
                        
                        // Redraw heatmap after resize
                        if (state.heatmapData) {
                            renderHeatmap();
                        }
                    }
                }
            });
            
            state.resizeObserver.observe(chartContainer);
        }

        // Fetch all data
        async function fetchAllData() {
            loadingIndicator.style.display = 'block';
            
            try {
                // Fetch data in parallel
                const [heatmapData, candleData] = await Promise.all([
                    fetchHeatmapData(),
                    fetchCandleData()
                ]);
                
                // Update state
                state.heatmapData = heatmapData;
                state.lastUpdated = new Date();
                
                // Process and render heatmap
                renderHeatmap();
                
                // Update candlestick chart
                updateCandleChart(candleData);
                
                // Update UI elements
                updateLastUpdatedDisplay();
                
                loadingIndicator.style.display = 'none';
                
                // Fetch current price separately
                fetchCurrentPrice();
            } catch (error) {
                console.error("Error fetching data:", error);
                loadingIndicator.textContent = "Error loading data. Please try again.";
            }
        }

        // Fetch heatmap data from backend
        async function fetchHeatmapData() {
            const params = new URLSearchParams({
                symbol: CONFIG.symbol,
                bucketSize: CONFIG.bucketSize,
                maxBuckets: CONFIG.maxBuckets,
                start: new Date(Date.now() - (CONFIG.timeframe === '1h' ? 3600000 : 86400000)).toISOString(),
                end: new Date().toISOString()
            });
            
            const response = await fetch(`${CONFIG.apiBaseUrl}/api/orderbook/heatmap?${params}`);
            
            if (!response.ok) {
                throw new Error(`Failed to fetch heatmap data: ${response.status}`);
            }
            
            return await response.json();
        }

        // Fetch candle data from Binance
        async function fetchCandleData() {
            // Using Binance Kline/Candlestick API to get 1m candles for the last hour
            const interval = '1m';
            const limit = 60; // 60 candles = 1 hour
            
            const url = `https://api.binance.com/api/v3/klines?symbol=${CONFIG.symbol}&interval=${interval}&limit=${limit}`;
            const response = await fetch(url);
            
            if (!response.ok) {
                throw new Error(`Failed to fetch candle data: ${response.status}`);
            }
            
            const data = await response.json();
            
            // Format data for TradingView chart
            return data.map(kline => ({
                time: kline[0] / 1000, // Convert to seconds for TradingView
                open: parseFloat(kline[1]),
                high: parseFloat(kline[2]),
                low: parseFloat(kline[3]),
                close: parseFloat(kline[4])
            }));
        }

        // Fetch current price from Binance
        async function fetchCurrentPrice() {
            try {
                const response = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${CONFIG.symbol}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch price: ${response.status}`);
                }
                
                const data = await response.json();
                const price = parseFloat(data.price);
                
                // Update state
                state.currentPrice = price;
                
                // Update UI
                updatePriceDisplay();
                
                return price;
            } catch (error) {
                console.error("Error fetching price:", error);
                return null;
            }
        }

        // Update candle chart with new data
        function updateCandleChart(candleData) {
            if (state.candleSeries && candleData.length > 0) {
                state.candleSeries.setData(candleData);
                
                // Optionally update price marker
                if (state.currentPrice) {
                    state.chart.priceScale('right').applyOptions({
                        autoScale: true
                    });
                }
            }
        }

        // Render heatmap using D3
        function renderHeatmap() {
            if (!state.heatmapData || !state.chart) return;
            
            // Clear existing heatmap
            state.heatmapSVG.selectAll('*').remove();
            
            const { times, prices, bidVolumes, askVolumes } = state.heatmapData;
            
            // Get chart dimensions and scales
            const chartInfo = state.chart.timeScale().getVisibleLogicalRange();
            if (!chartInfo) return; // Chart not ready yet
            
            // Get visible price range
            const priceScale = state.chart.priceScale('right');
            const priceRange = priceScale.getVisibleLogicalRange();
            if (!priceRange) return; // Price scale not ready
            
            // Calculate cell dimensions
            const timeCount = times.length;
            const priceCount = prices.length;
            
            // Find max volume for color scaling
            let maxBidVolume = 0;
            let maxAskVolume = 0;
            
            for (let t = 0; t < timeCount; t++) {
                for (let p = 0; p < priceCount; p++) {
                    if (bidVolumes[t] && bidVolumes[t][p]) {
                        maxBidVolume = Math.max(maxBidVolume, bidVolumes[t][p]);
                    }
                    if (askVolumes[t] && askVolumes[t][p]) {
                        maxAskVolume = Math.max(maxAskVolume, askVolumes[t][p]);
                    }
                }
            }
            
            // Apply log scaling for better visualization
            maxBidVolume = Math.log(maxBidVolume + 1);
            maxAskVolume = Math.log(maxAskVolume + 1);
            
            // Create heatmap cells
            const heatmapCells = [];
            
            for (let t = 0; t < timeCount; t++) {
                const time = new Date(times[t]).getTime() / 1000; // Convert to seconds for TV chart
                
                for (let p = 0; p < priceCount; p++) {
                    const price = prices[p];
                    
                    // Get volumes (with safety checks)
                    const bidVol = bidVolumes[t] && bidVolumes[t][p] ? bidVolumes[t][p] : 0;
                    const askVol = askVolumes[t] && askVolumes[t][p] ? askVolumes[t][p] : 0;
                    
                    // Determine cell color
                    let color;
                    if (bidVol > askVol) {
                        // Bid dominant - green
                        const intensity = Math.log(bidVol + 1) / maxBidVolume;
                        const colorIndex = Math.min(Math.floor(intensity * CONFIG.heatmapColors.bids.length), CONFIG.heatmapColors.bids.length - 1);
                        color = CONFIG.heatmapColors.bids[colorIndex];
                    } else if (askVol > bidVol) {
                        // Ask dominant - red
                        const intensity = Math.log(askVol + 1) / maxAskVolume;
                        const colorIndex = Math.min(Math.floor(intensity * CONFIG.heatmapColors.asks.length), CONFIG.heatmapColors.asks.length - 1);
                        color = CONFIG.heatmapColors.asks[colorIndex];
                    } else {
                        // Neutral - dark teal
                        color = CONFIG.heatmapColors.neutral;
                    }
                    
                    heatmapCells.push({
                        time,
                        price,
                        color
                    });
                }
            }
            
            // Draw cells using D3 and TradingView coordinates
            heatmapCells.forEach(cell => {
                // Convert logical coordinates to pixel coordinates
                const x = state.chart.timeScale().logicalToCoordinate(cell.time);
                const y = priceScale.logicalToCoordinate(cell.price);
                
                // Skip if out of bounds
                if (x === null || y === null) return;
                
                // Calculate cell size (approximate)
                const nextTimeIndex = times.indexOf(times[times.findIndex(t => new Date(t).getTime() / 1000 === cell.time) + 1]);
                const nextTime = nextTimeIndex !== -1 ? new Date(times[nextTimeIndex]).getTime() / 1000 : cell.time + 60;
                const nextX = state.chart.timeScale().logicalToCoordinate(nextTime);
                
                const cellWidth = nextX !== null ? Math.abs(nextX - x) : 5;
                
                const nextPriceIndex = prices.indexOf(prices[prices.indexOf(cell.price) + 1]);
                const nextPrice = nextPriceIndex !== -1 ? prices[nextPriceIndex] : cell.price * 1.0001;
                const nextY = priceScale.logicalToCoordinate(nextPrice);
                
                const cellHeight = nextY !== null ? Math.abs(y - nextY) : 5;
                
                // Draw cell rectangle
                state.heatmapSVG.append('rect')
                    .attr('x', x)
                    .attr('y', y - cellHeight)
                    .attr('width', cellWidth)
                    .attr('height', cellHeight)
                    .attr('fill', cell.color)
                    .attr('opacity', 0.8); // Slight transparency to see candles better
            });
        }

        // Update price display
        function updatePriceDisplay() {
            if (state.currentPrice) {
                // Format price based on value (more decimals for lower priced assets)
                const decimals = state.currentPrice < 1 ? 4 : (state.currentPrice < 10 ? 3 : 2);
                priceDisplay.textContent = state.currentPrice.toFixed(decimals);
                
                // Color based on price movement (if we have previous price in state)
                if (state.previousPrice) {
                    const priceChange = state.currentPrice - state.previousPrice;
                    priceDisplay.style.color = priceChange >= 0 ? '#4AFA9A' : '#FA4A83';
                }
                
                // Store current price for next comparison
                state.previousPrice = state.currentPrice;
            }
        }

        // Update last updated timestamp
        function updateLastUpdatedDisplay() {
            if (state.lastUpdated) {
                lastUpdatedDisplay.textContent = `Last updated: ${state.lastUpdated.toLocaleTimeString()}`;
            }
        }

        // Start the application
        window.addEventListener('load', init);
    </script>
</body>
</html>
