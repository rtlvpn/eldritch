<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orderbook Heatmap Visualization</title>
    <style>
        body {
            background-color: #0a0a14;
            color: #e0e0e0;
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        #container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
        #header {
            padding: 10px;
            background-color: #161627;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #333;
        }
        
        #symbolInfo {
            font-size: 18px;
            font-weight: bold;
        }
        
        #priceInfo {
            font-size: 18px;
        }
        
        #canvasContainer {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        #heatmapCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #priceCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        #rightAxis {
            position: absolute;
            top: 0;
            right: 0;
            width: 80px;
            height: 100%;
            background-color: rgba(10, 10, 20, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px 0;
            box-sizing: border-box;
            border-left: 1px solid #333;
            z-index: 10;
        }
        
        .priceLabel {
            text-align: right;
            padding-right: 10px;
            font-size: 12px;
        }
        
        #currentPrice {
            position: absolute;
            right: 0;
            background-color: #f33;
            color: white;
            padding: 2px 8px;
            font-size: 12px;
            z-index: 100;
            border-radius: 2px 0 0 2px;
            box-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            transform: translateY(-50%);
        }
        
        #currentTime {
            position: absolute;
            right: 81px;
            bottom: 5px;
            background-color: #f33;
            color: white;
            padding: 2px 5px;
            font-size: 11px;
            z-index: 100;
            border-radius: 2px;
        }
        
        #status {
            position: absolute;
            left: 10px;
            top: 10px;
            padding: 5px 10px;
            background-color: rgba(0, 0, 0, 0.7);
            border-radius: 5px;
            z-index: 100;
            font-size: 12px;
        }
        
        .connected {
            color: #4CAF50;
        }
        
        .disconnected {
            color: #F44336;
        }
        
        .loading {
            color: #FFC107;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="header">
            <div id="symbolInfo">TRXUSDT Orderbook Heatmap</div>
            <div id="priceInfo">Loading...</div>
        </div>
        <div id="canvasContainer">
            <canvas id="heatmapCanvas"></canvas>
            <canvas id="priceCanvas"></canvas>
            <div id="rightAxis"></div>
            <div id="currentPrice"></div>
            <div id="currentTime"></div>
            <div id="status" class="loading">Connecting...</div>
        </div>
    </div>

    <script>
        // Configuration
        const wsUrl = 'wss://heatmapeldritch.gleeze.com:3500';
        const symbol = 'TRXUSDT';
        
        // State variables
        let heatmapData = null;
        let canvasWidth = 0;
        let canvasHeight = 0;
        let socket = null;
        let reconnectInterval = null;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 5;
        let reconnectDelay = 2000;
        
        // DOM elements
        const heatmapCanvas = document.getElementById('heatmapCanvas');
        const priceCanvas = document.getElementById('priceCanvas');
        const rightAxis = document.getElementById('rightAxis');
        const currentPriceEl = document.getElementById('currentPrice');
        const currentTimeEl = document.getElementById('currentTime');
        const statusEl = document.getElementById('status');
        const priceInfoEl = document.getElementById('priceInfo');
        const heatmapCtx = heatmapCanvas.getContext('2d');
        const priceCtx = priceCanvas.getContext('2d');
        
        // Initialize canvas size
        function initCanvas() {
            const container = document.getElementById('canvasContainer');
            canvasWidth = container.clientWidth;
            canvasHeight = container.clientHeight;
            
            heatmapCanvas.width = canvasWidth;
            heatmapCanvas.height = canvasHeight;
            priceCanvas.width = canvasWidth;
            priceCanvas.height = canvasHeight;
        }
        
        // Connect to WebSocket
        function connectWebSocket() {
            if (socket) {
                socket.close();
            }
            
            statusEl.className = 'loading';
            statusEl.textContent = 'Connecting...';
            
            socket = new WebSocket(wsUrl);
            
            socket.onopen = function() {
                console.log('WebSocket connected');
                statusEl.className = 'connected';
                statusEl.textContent = 'Connected';
                reconnectAttempts = 0;
                
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
                
                // Subscribe to heatmap data
                socket.send(JSON.stringify({
                    action: 'subscribe',
                    topics: ['heatmap', 'orderbook']
                }));
            };
            
            socket.onmessage = function(event) {
                try {
                    const message = JSON.parse(event.data);
                    
                    if (message.type === 'heatmap') {
                        heatmapData = message.data;
                        renderHeatmap();
                    } else if (message.type === 'orderbook') {
                        updatePriceInfo(message.data);
                    } else if (message.type === 'subscription') {
                        console.log('Subscribed to:', message.topics);
                    } else if (message.type === 'error') {
                        console.error('Server error:', message.message);
                    }
                } catch (err) {
                    console.error('Error processing message:', err);
                }
            };
            
            socket.onclose = function() {
                statusEl.className = 'disconnected';
                statusEl.textContent = 'Disconnected';
                
                if (reconnectAttempts < maxReconnectAttempts && !reconnectInterval) {
                    reconnectInterval = setTimeout(() => {
                        reconnectAttempts++;
                        console.log(`Reconnecting (${reconnectAttempts}/${maxReconnectAttempts})...`);
                        connectWebSocket();
                    }, reconnectDelay);
                }
            };
            
            socket.onerror = function(error) {
                console.error('WebSocket error:', error);
                statusEl.className = 'disconnected';
                statusEl.textContent = 'Connection Error';
            };
        }
        
        // Update price info in header
        function updatePriceInfo(data) {
            if (data && data.metrics) {
                const price = data.metrics.midPrice.toFixed(4);
                const bid = data.metrics.bestBid.toFixed(4);
                const ask = data.metrics.bestAsk.toFixed(4);
                const spread = data.metrics.spread.toFixed(6);
                const imbalance = (data.metrics.imbalance * 100).toFixed(2);
                
                const imbalanceColor = data.metrics.imbalance > 0 
                    ? 'color: #4CAF50;' // Green for positive (more bids)
                    : 'color: #F44336;'; // Red for negative (more asks)
                
                priceInfoEl.innerHTML = `
                    Price: <span style="color: #FFC107;">${price}</span> | 
                    Bid: <span style="color: #4CAF50;">${bid}</span> | 
                    Ask: <span style="color: #F44336;">${ask}</span> | 
                    Spread: ${spread} | 
                    Imbalance: <span style="${imbalanceColor}">${imbalance}%</span>
                `;
            }
        }
        
        // Render the heatmap visualization
        function renderHeatmap() {
            if (!heatmapData) return;
            
            const {
                times,
                prices,
                bidVolumes,
                askVolumes,
                midPrices,
                currentPrice,
                minPrice,
                maxPrice
            } = heatmapData;
            
            // Clear canvases
            heatmapCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            priceCtx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // Calculate dimensions
            const effectiveWidth = canvasWidth - 80; // Subtract right axis width
            const pxPerTimeStep = effectiveWidth / times.length;
            const pxPerPriceStep = canvasHeight / (maxPrice - minPrice);
            
            // Find global max volume for color scaling
            let maxVolume = 0;
            for (let t = 0; t < times.length; t++) {
                for (let p = 0; p < prices.length; p++) {
                    maxVolume = Math.max(
                        maxVolume, 
                        bidVolumes[t] ? bidVolumes[t][p] || 0 : 0,
                        askVolumes[t] ? askVolumes[t][p] || 0 : 0
                    );
                }
            }
            
            // Render heatmap cells
            for (let t = 0; t < times.length; t++) {
                const x = t * pxPerTimeStep;
                
                for (let p = 0; p < prices.length; p++) {
                    const price = prices[p];
                    const y = canvasHeight - ((price - minPrice) * pxPerPriceStep);
                    
                    const bidVol = bidVolumes[t] ? bidVolumes[t][p] || 0 : 0;
                    const askVol = askVolumes[t] ? askVolumes[t][p] || 0 : 0;
                    
                    // Choose color based on whether it's a bid or ask
                    // and intensity based on volume relative to max
                    if (bidVol > 0) {
                        const intensity = Math.pow(bidVol / maxVolume, 0.5); // Square root for better visual scaling
                        heatmapCtx.fillStyle = getBidColor(intensity);
                        heatmapCtx.fillRect(x, y, pxPerTimeStep, pxPerPriceStep);
                    } else if (askVol > 0) {
                        const intensity = Math.pow(askVol / maxVolume, 0.5);
                        heatmapCtx.fillStyle = getAskColor(intensity);
                        heatmapCtx.fillRect(x, y, pxPerTimeStep, pxPerPriceStep);
                    }
                }
            }
            
            // Render price line
            priceCtx.beginPath();
            priceCtx.lineWidth = 1.5;
            priceCtx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
            
            for (let t = 0; t < times.length; t++) {
                const x = t * pxPerTimeStep;
                const midPrice = midPrices[t];
                const y = canvasHeight - ((midPrice - minPrice) * pxPerPriceStep);
                
                if (t === 0) {
                    priceCtx.moveTo(x, y);
                } else {
                    priceCtx.lineTo(x, y);
                }
            }
            
            priceCtx.stroke();
            
            // Update price labels on the right axis
            updatePriceAxis(minPrice, maxPrice);
            
            // Update current price indicator
            if (currentPrice) {
                const priceY = canvasHeight - ((currentPrice - minPrice) * pxPerPriceStep);
                currentPriceEl.style.top = priceY + 'px';
                currentPriceEl.textContent = currentPrice.toFixed(4);
                
                // Add horizontal line at current price
                priceCtx.beginPath();
                priceCtx.setLineDash([5, 3]);
                priceCtx.lineWidth = 1;
                priceCtx.strokeStyle = 'rgba(255, 51, 51, 0.8)';
                priceCtx.moveTo(0, priceY);
                priceCtx.lineTo(effectiveWidth, priceY);
                priceCtx.stroke();
                priceCtx.setLineDash([]);
            }
            
            // Update current time
            if (times.length > 0) {
                const lastTime = times[times.length - 1];
                const timeStr = lastTime.split(' ')[1].substring(0, 5); // Extract HH:MM
                currentTimeEl.textContent = timeStr;
            }
        }
        
        // Generate color for bid volumes
        function getBidColor(intensity) {
            // Bids in green-yellow spectrum
            const g = Math.floor(180 * intensity) + 75;
            const r = Math.floor(255 * intensity);
            const b = Math.floor(20 * intensity);
            const alpha = 0.2 + (intensity * 0.8);
            
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Generate color for ask volumes
        function getAskColor(intensity) {
            // Asks in cyan-blue spectrum
            const r = Math.floor(20 * intensity);
            const g = Math.floor(180 * intensity) + 75;
            const b = Math.floor(255 * intensity);
            const alpha = 0.2 + (intensity * 0.8);
            
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Update price axis labels
        function updatePriceAxis(minPrice, maxPrice) {
            rightAxis.innerHTML = '';
            const numLabels = 10;
            
            for (let i = 0; i <= numLabels; i++) {
                const price = maxPrice - ((maxPrice - minPrice) * (i / numLabels));
                const label = document.createElement('div');
                label.className = 'priceLabel';
                label.textContent = price.toFixed(2);
                rightAxis.appendChild(label);
            }
        }
        
        // Handle window resize
        function handleResize() {
            initCanvas();
            renderHeatmap();
        }
        
        // Initialize the application
        function init() {
            initCanvas();
            connectWebSocket();
            window.addEventListener('resize', handleResize);
        }
        
        // Start the application when the page loads
        window.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
