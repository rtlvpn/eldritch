package main

import (
	"context"
	"crypto/tls"
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"os/signal"
	"path/filepath"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/gorilla/mux"
	_ "github.com/mattn/go-sqlite3"
	"github.com/quic-go/quic-go/http3"
	"golang.org/x/time/rate"
)

// Config holds all application configuration
type Config struct {
	Symbol         string
	Interval       time.Duration
	OrderbookDepth int
	DatabasePath   string
	BinanceBaseURL string
	RetryDelay     time.Duration
	MaxRetries     int
	APIPort        int
	APIPortHTTPS   int
	APIPortHTTP3   int
	CertPath       string
	PrivKeyPath    string
}

// TickerResponse represents Binance ticker response
type TickerResponse struct {
	Symbol string `json:"symbol"`
	Price  string `json:"price"`
}

// OrderbookResponse represents Binance orderbook response
type OrderbookResponse struct {
	LastUpdateID int         `json:"lastUpdateId"`
	Bids         [][2]string `json:"bids"`
	Asks         [][2]string `json:"asks"`
}

// OHLCData represents candlestick data
type OHLCData struct {
	Timestamp int64   `json:"timestamp"`
	Open      float64 `json:"open"`
	High      float64 `json:"high"`
	Low       float64 `json:"low"`
	Close     float64 `json:"close"`
}

// TimeRange represents min and max timestamps in the database
type TimeRange struct {
	MinTime int64 `json:"min_time"`
	MaxTime int64 `json:"max_time"`
}

// HeatmapItem represents a single timestamp's heatmap data
type HeatmapItem struct {
	Timestamp int64     `json:"timestamp"`
	Volumes   []float64 `json:"volumes"`
}

// HeatmapResponse represents the full heatmap data structure
type HeatmapResponse struct {
	Timestamps  []int64       `json:"timestamps"`
	PriceLevels []float64     `json:"priceLevels"`
	Heatmap     []HeatmapItem `json:"heatmap"`
}

// Global variables
var (
	config       Config
	db           *sql.DB
	isCollecting bool
	collectMutex sync.Mutex
)

func main() {
	// Initialize configuration
	config = Config{
		Symbol:         "TRXUSDT",
		Interval:       60 * time.Second,
		OrderbookDepth: 5000,
		DatabasePath:   filepath.Join("data", "trx_orderbook.db"),
		BinanceBaseURL: "https://api.binance.com/api/v3",
		RetryDelay:     5 * time.Second,
		MaxRetries:     3,
		APIPort:        getEnvAsInt("PORT", 3000),
		APIPortHTTPS:   getEnvAsInt("HTTPS_PORT", 3500),
		APIPortHTTP3:   getEnvAsInt("HTTP3_PORT", 3500),
		CertPath:       getEnv("CERT_PATH", "/etc/letsencrypt/live/heatmapeldritch.gleeze.com/fullchain.pem"),
		PrivKeyPath:    getEnv("PRIVKEY_PATH", "/etc/letsencrypt/live/heatmapeldritch.gleeze.com/privkey.pem"),
	}

	// Ensure data directory exists
	dataDir := filepath.Dir(config.DatabasePath)
	if err := os.MkdirAll(dataDir, 0755); err != nil {
		log.Fatalf("Failed to create data directory: %v", err)
	}

	// Initialize database
	var err error
	db, err = sql.Open("sqlite3", config.DatabasePath)
	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}
	defer db.Close()

	// Set connection pool parameters
	db.SetMaxOpenConns(1) // SQLite supports only one writer at a time
	db.SetMaxIdleConns(1)
	db.SetConnMaxLifetime(time.Hour)

	log.Printf("Connected to database at %s", config.DatabasePath)

	// Initialize database tables
	initializeDatabase()

	startApplication()
}

// Helper functions for environment variables
func getEnv(key, fallback string) string {
	if value, exists := os.LookupEnv(key); exists {
		return value
	}
	return fallback
}

func getEnvAsInt(key string, fallback int) int {
	strVal := getEnv(key, "")
	if value, err := strconv.Atoi(strVal); err == nil {
		return value
	}
	return fallback
}

// Initialize database tables and indexes
func initializeDatabase() {
	statements := []string{
		`CREATE TABLE IF NOT EXISTS ticker_data (
			timestamp INTEGER PRIMARY KEY,
			price REAL NOT NULL,
			created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
		)`,
		`CREATE TABLE IF NOT EXISTS orderbook_data (
			id INTEGER PRIMARY KEY AUTOINCREMENT,
			timestamp INTEGER NOT NULL,
			price_level REAL NOT NULL,
			quantity REAL NOT NULL,
			side TEXT NOT NULL,
			FOREIGN KEY (timestamp) REFERENCES ticker_data (timestamp)
		)`,
		`CREATE INDEX IF NOT EXISTS idx_orderbook_timestamp ON orderbook_data (timestamp)`,
		`CREATE INDEX IF NOT EXISTS idx_orderbook_side ON orderbook_data (side)`,
		`CREATE INDEX IF NOT EXISTS idx_orderbook_price_level ON orderbook_data (price_level)`,
		`CREATE INDEX IF NOT EXISTS idx_orderbook_timestamp_price ON orderbook_data (timestamp, price_level)`,
		`PRAGMA journal_mode = WAL`,
		`PRAGMA synchronous = NORMAL`,
		`PRAGMA cache_size = -32000`, // 32MB cache
		`PRAGMA temp_store = MEMORY`,
		`PRAGMA mmap_size = 268435456`, // 256MB mmap
	}

	for _, stmt := range statements {
		_, err := db.Exec(stmt)
		if err != nil {
			log.Fatalf("Database initialization error: %v", err)
		}
	}

	log.Println("Database initialized successfully")
}

// API functions
func fetchTickerPrice(ctx context.Context, retries int) (float64, error) {
	url := fmt.Sprintf("%s/ticker/price?symbol=%s", config.BinanceBaseURL, config.Symbol)

	for i := 0; i <= retries; i++ {
		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			return 0, err
		}

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			if i < retries {
				log.Printf("Error fetching ticker price, retrying (%d attempts left): %v", retries-i, err)
				time.Sleep(config.RetryDelay)
				continue
			}
			return 0, err
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			body, _ := ioutil.ReadAll(resp.Body)
			if i < retries {
				log.Printf("Error fetching ticker price (status %d), retrying (%d attempts left): %s",
					resp.StatusCode, retries-i, string(body))
				time.Sleep(config.RetryDelay)
				continue
			}
			return 0, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
		}

		var tickerResp TickerResponse
		if err := json.NewDecoder(resp.Body).Decode(&tickerResp); err != nil {
			if i < retries {
				log.Printf("Error decoding ticker response, retrying (%d attempts left): %v", retries-i, err)
				time.Sleep(config.RetryDelay)
				continue
			}
			return 0, err
		}

		price, err := strconv.ParseFloat(tickerResp.Price, 64)
		if err != nil {
			return 0, fmt.Errorf("invalid price format: %v", err)
		}
		return price, nil
	}

	return 0, fmt.Errorf("failed to fetch ticker price after %d attempts", retries+1)
}

func fetchOrderbook(ctx context.Context, retries int) (OrderbookResponse, error) {
	url := fmt.Sprintf("%s/depth?symbol=%s&limit=%d",
		config.BinanceBaseURL, config.Symbol, config.OrderbookDepth)

	var orderbook OrderbookResponse

	for i := 0; i <= retries; i++ {
		req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
		if err != nil {
			return orderbook, err
		}

		resp, err := http.DefaultClient.Do(req)
		if err != nil {
			if i < retries {
				log.Printf("Error fetching orderbook, retrying (%d attempts left): %v", retries-i, err)
				time.Sleep(config.RetryDelay)
				continue
			}
			return orderbook, err
		}
		defer resp.Body.Close()

		if resp.StatusCode != http.StatusOK {
			body, _ := ioutil.ReadAll(resp.Body)
			if i < retries {
				log.Printf("Error fetching orderbook (status %d), retrying (%d attempts left): %s",
					resp.StatusCode, retries-i, string(body))
				time.Sleep(config.RetryDelay)
				continue
			}
			return orderbook, fmt.Errorf("API error (status %d): %s", resp.StatusCode, string(body))
		}

		if err := json.NewDecoder(resp.Body).Decode(&orderbook); err != nil {
			if i < retries {
				log.Printf("Error decoding orderbook response, retrying (%d attempts left): %v", retries-i, err)
				time.Sleep(config.RetryDelay)
				continue
			}
			return orderbook, err
		}

		return orderbook, nil
	}

	return orderbook, fmt.Errorf("failed to fetch orderbook after %d attempts", retries+1)
}

// Database operations
func saveData(timestamp int64, price float64, orderbook OrderbookResponse) bool {
	tx, err := db.Begin()
	if err != nil {
		log.Printf("Error beginning transaction: %v", err)
		return false
	}
	defer func() {
		if p := recover(); p != nil {
			tx.Rollback()
			panic(p)
		}
	}()

	// Insert ticker data
	_, err = tx.Exec("INSERT INTO ticker_data (timestamp, price) VALUES (?, ?)", timestamp, price)
	if err != nil {
		tx.Rollback()
		log.Printf("Error inserting ticker data: %v", err)
		return false
	}

	// Prepare statement for orderbook data
	stmt, err := tx.Prepare("INSERT INTO orderbook_data (timestamp, price_level, quantity, side) VALUES (?, ?, ?, ?)")
	if err != nil {
		tx.Rollback()
		log.Printf("Error preparing orderbook statement: %v", err)
		return false
	}
	defer stmt.Close()

	// Insert bids
	for _, bid := range orderbook.Bids {
		priceLevel, _ := strconv.ParseFloat(bid[0], 64)
		quantity, _ := strconv.ParseFloat(bid[1], 64)
		_, err = stmt.Exec(timestamp, priceLevel, quantity, "buy")
		if err != nil {
			tx.Rollback()
			log.Printf("Error inserting bid data: %v", err)
			return false
		}
	}

	// Insert asks
	for _, ask := range orderbook.Asks {
		priceLevel, _ := strconv.ParseFloat(ask[0], 64)
		quantity, _ := strconv.ParseFloat(ask[1], 64)
		_, err = stmt.Exec(timestamp, priceLevel, quantity, "sell")
		if err != nil {
			tx.Rollback()
			log.Printf("Error inserting ask data: %v", err)
			return false
		}
	}

	if err = tx.Commit(); err != nil {
		log.Printf("Error committing transaction: %v", err)
		return false
	}

	return true
}

// Query functions
func getLatestTickerData() map[string]interface{} {
	row := db.QueryRow("SELECT * FROM ticker_data ORDER BY timestamp DESC LIMIT 1")

	var timestamp int64
	var price float64
	var createdAt string

	if err := row.Scan(&timestamp, &price, &createdAt); err != nil {
		log.Printf("Error getting latest ticker data: %v", err)
		return nil
	}

	return map[string]interface{}{
		"timestamp":  timestamp,
		"price":      price,
		"created_at": createdAt,
	}
}

func getOrderbookSnapshot(timestamp int64) []map[string]interface{} {
	rows, err := db.Query(`
		SELECT price_level, quantity, side
		FROM orderbook_data
		WHERE timestamp = ?
		ORDER BY side, price_level
	`, timestamp)

	if err != nil {
		log.Printf("Error getting orderbook snapshot: %v", err)
		return []map[string]interface{}{}
	}
	defer rows.Close()

	result := []map[string]interface{}{}
	for rows.Next() {
		var priceLevel, quantity float64
		var side string

		if err := rows.Scan(&priceLevel, &quantity, &side); err != nil {
			log.Printf("Error scanning orderbook row: %v", err)
			continue
		}

		result = append(result, map[string]interface{}{
			"price_level": priceLevel,
			"quantity":    quantity,
			"side":        side,
		})
	}

	return result
}

func getCandlestickData(startTime, endTime int64, interval int) []OHLCData {
	query := `
		WITH time_intervals AS (
			SELECT 
				(timestamp / ?) * ? AS interval_start,
				MAX(timestamp) AS max_time,
				MIN(timestamp) AS min_time,
				MAX(price) AS high,
				MIN(price) AS low,
				FIRST_VALUE(price) OVER (PARTITION BY (timestamp / ?) * ? ORDER BY timestamp) AS open,
				LAST_VALUE(price) OVER (PARTITION BY (timestamp / ?) * ? ORDER BY timestamp 
					RANGE BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS close
			FROM ticker_data
			WHERE timestamp BETWEEN ? AND ?
			GROUP BY interval_start
		)
		SELECT 
			interval_start * 1000 AS timestamp,
			open, high, low, close
		FROM time_intervals
		ORDER BY interval_start
	`

	rows, err := db.Query(query, interval, interval, interval, interval, interval, interval, startTime, endTime)
	if err != nil {
		log.Printf("Error getting candlestick data: %v", err)
		return []OHLCData{}
	}
	defer rows.Close()

	result := []OHLCData{}
	for rows.Next() {
		var ohlc OHLCData
		if err := rows.Scan(&ohlc.Timestamp, &ohlc.Open, &ohlc.High, &ohlc.Low, &ohlc.Close); err != nil {
			log.Printf("Error scanning candlestick row: %v", err)
			continue
		}
		result = append(result, ohlc)
	}

	return result
}

func getHeatmapData(startTime, endTime int64, priceBuckets int) HeatmapResponse {
	var response HeatmapResponse

	// 1. Get the price range - simple and fast query
	var minPrice, maxPrice sql.NullFloat64
	err := db.QueryRow(`
		SELECT MIN(price) AS min_price, MAX(price) AS max_price
		FROM ticker_data
		WHERE timestamp BETWEEN ? AND ?
	`, startTime, endTime).Scan(&minPrice, &maxPrice)

	if err != nil || !minPrice.Valid || !maxPrice.Valid {
		log.Printf("Error getting price range: %v", err)
		return response
	}

	// Add margin to price range
	margin := (maxPrice.Float64 - minPrice.Float64) * 0.30
	min := minPrice.Float64 - margin
	max := maxPrice.Float64 + margin
	priceStep := (max - min) / float64(priceBuckets)

	// 2. First get just the timestamps - this is very fast in SQLite with an index
	rows, err := db.Query(`
		SELECT DISTINCT timestamp 
		FROM ticker_data
		WHERE timestamp BETWEEN ? AND ?
		ORDER BY timestamp
	`, startTime, endTime)

	if err != nil {
		log.Printf("Error getting timestamps: %v", err)
		return response
	}

	var timestamps []int64
	for rows.Next() {
		var ts int64
		if err := rows.Scan(&ts); err != nil {
			log.Printf("Error scanning timestamp: %v", err)
			continue
		}
		timestamps = append(timestamps, ts)
	}
	rows.Close()

	if len(timestamps) == 0 {
		return response
	}

	// 3. Generate price levels
	priceLevels := make([]float64, priceBuckets)
	for i := 0; i < priceBuckets; i++ {
		priceLevels[i] = min + float64(i)*priceStep
	}

	// 4. Prepare the efficient query once - avoiding repeated preparations
	stmt, err := db.Prepare(`
		SELECT 
			CAST((price_level - ?) / ? AS INTEGER) AS bucket_index,
			SUM(CASE WHEN side = 'buy' THEN quantity ELSE -quantity END) AS volume
		FROM orderbook_data
		WHERE timestamp = ? AND price_level BETWEEN ? AND ?
		GROUP BY bucket_index
		HAVING bucket_index BETWEEN 0 AND ?
	`)

	if err != nil {
		log.Printf("Error preparing statement: %v", err)
		return response
	}
	defer stmt.Close()

	// 5. Create the return structures once and reuse
	heatmapItems := make([]HeatmapItem, 0, len(timestamps))

	// 6. Use batching for timestamps - processing chunks of timestamps at a time
	batchSize := 50 // Adjust based on testing
	for i := 0; i < len(timestamps); i += batchSize {
		end := i + batchSize
		if end > len(timestamps) {
			end = len(timestamps)
		}

		for j := i; j < end; j++ {
			ts := timestamps[j]

			// Execute the prepared statement for each timestamp
			bucketRows, err := stmt.Query(min, priceStep, ts, min, max, priceBuckets-1)
			if err != nil {
				log.Printf("Error querying for timestamp %d: %v", ts, err)
				continue
			}

			// Initialize volumes array with zeros
			volumes := make([]float64, priceBuckets)

			// Fill in the non-zero values
			for bucketRows.Next() {
				var bucketIndex int
				var volume float64
				if err := bucketRows.Scan(&bucketIndex, &volume); err != nil {
					log.Printf("Error scanning bucket row: %v", err)
					continue
				}

				if bucketIndex >= 0 && bucketIndex < priceBuckets {
					volumes[bucketIndex] = volume
				}
			}
			bucketRows.Close()

			heatmapItems = append(heatmapItems, HeatmapItem{
				Timestamp: ts,
				Volumes:   volumes,
			})
		}
	}

	// 7. Construct the final response
	response = HeatmapResponse{
		Timestamps:  timestamps,
		PriceLevels: priceLevels,
		Heatmap:     heatmapItems,
	}

	return response
}

// Data collection
func collectData() {
	timestamp := time.Now().Unix()

	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	log.Printf("[%s] Fetching data for %s", time.Now().Format(time.RFC3339), config.Symbol)

	price, err := fetchTickerPrice(ctx, config.MaxRetries)
	if err != nil {
		log.Printf("Failed to fetch ticker price: %v", err)
		return
	}

	orderbook, err := fetchOrderbook(ctx, config.MaxRetries)
	if err != nil {
		log.Printf("Failed to fetch orderbook: %v", err)
		return
	}

	if saveData(timestamp, price, orderbook) {
		log.Printf("Data saved successfully. Price: %f, Bids: %d, Asks: %d",
			price, len(orderbook.Bids), len(orderbook.Asks))
	}
}

func scheduleDataCollection() {
	collectMutex.Lock()
	if isCollecting {
		collectMutex.Unlock()
		return
	}
	isCollecting = true
	collectMutex.Unlock()

	collectData()

	collectMutex.Lock()
	isCollecting = false
	collectMutex.Unlock()
}

// Rate limiting middleware
func rateLimiterMiddleware(next http.Handler) http.Handler {
	limiter := rate.NewLimiter(rate.Every(15*time.Minute/100), 1) // 100 requests per 15 minutes

	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if !limiter.Allow() {
			http.Error(w, "Rate limit exceeded", http.StatusTooManyRequests)
			return
		}
		next.ServeHTTP(w, r)
	})
}

// CORS middleware handler
func corsMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Set CORS headers
		w.Header().Set("Access-Control-Allow-Origin", "*") // Allow all origins, or set specific: "https://rtlvpn.github.io"
		w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
		w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization")

		// Handle preflight requests
		if r.Method == "OPTIONS" {
			w.WriteHeader(http.StatusOK)
			return
		}

		next.ServeHTTP(w, r)
	})
}

// HTTP version middleware
func httpVersionMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Add a header indicating the HTTP version
		proto := r.Proto

		// Check for HTTP/3 specifically
		if r.ProtoMajor == 3 || strings.Contains(r.Proto, "QUIC") || strings.Contains(r.Proto, "h3") {
			proto = "HTTP/3"
		}

		w.Header().Set("X-HTTP-Version", proto)
		next.ServeHTTP(w, r)
	})
}

// API handlers
func handleLatestTicker(w http.ResponseWriter, r *http.Request) {
	data := getLatestTickerData()
	if data == nil {
		json.NewEncoder(w).Encode(map[string]string{"error": "No data available"})
		return
	}
	json.NewEncoder(w).Encode(data)
}

func handleCandlesticks(w http.ResponseWriter, r *http.Request) {
	endTime, _ := strconv.ParseInt(r.URL.Query().Get("endTime"), 10, 64)
	if endTime == 0 {
		endTime = time.Now().Unix()
	}

	startTime, _ := strconv.ParseInt(r.URL.Query().Get("startTime"), 10, 64)
	if startTime == 0 {
		startTime = endTime - 3600 // Default to last hour
	}

	interval, _ := strconv.Atoi(r.URL.Query().Get("interval"))
	if interval == 0 {
		interval = 60 // Default to 1 minute
	}

	data := getCandlestickData(startTime, endTime, interval)
	json.NewEncoder(w).Encode(data)
}

func handleOrderbook(w http.ResponseWriter, r *http.Request) {
	vars := mux.Vars(r)
	timestamp, err := strconv.ParseInt(vars["timestamp"], 10, 64)
	if err != nil {
		http.Error(w, "Invalid timestamp", http.StatusBadRequest)
		return
	}

	data := getOrderbookSnapshot(timestamp)
	json.NewEncoder(w).Encode(data)
}

func handleHeatmap(w http.ResponseWriter, r *http.Request) {
	endTime, _ := strconv.ParseInt(r.URL.Query().Get("endTime"), 10, 64)
	if endTime == 0 {
		endTime = time.Now().Unix()
	}

	startTime, _ := strconv.ParseInt(r.URL.Query().Get("startTime"), 10, 64)
	if startTime == 0 {
		startTime = endTime - 3600 // Default to last hour
	}

	buckets, _ := strconv.Atoi(r.URL.Query().Get("buckets"))
	if buckets == 0 {
		buckets = 100 // Default to 100 buckets
	}

	data := getHeatmapData(startTime, endTime, buckets)
	json.NewEncoder(w).Encode(data)
}

func handleTimeRange(w http.ResponseWriter, r *http.Request) {
	var timeRange TimeRange
	err := db.QueryRow(`
		SELECT MIN(timestamp) AS min_time, MAX(timestamp) AS max_time
		FROM ticker_data
	`).Scan(&timeRange.MinTime, &timeRange.MaxTime)

	if err != nil {
		http.Error(w, "Database error", http.StatusInternalServerError)
		log.Printf("Error getting time range: %v", err)
		return
	}

	json.NewEncoder(w).Encode(timeRange)
}

// Initialize API server
func initializeAPI() (*http.Server, *http.Server, *http3.Server) {
	router := mux.NewRouter()

	// Apply middleware to all routes (CORS and rate limiting)
	router.Use(corsMiddleware) // Add CORS middleware to ALL routes

	// Apply rate limiting to API routes only
	apiRouter := router.PathPrefix("/api").Subrouter()
	apiRouter.Use(rateLimiterMiddleware)

	// Apply HTTP version middleware to API routes only
	apiRouter.Use(httpVersionMiddleware)

	// API routes
	apiRouter.HandleFunc("/ticker/latest", handleLatestTicker).Methods("GET")
	apiRouter.HandleFunc("/candlesticks", handleCandlesticks).Methods("GET")
	apiRouter.HandleFunc("/orderbook/{timestamp}", handleOrderbook).Methods("GET")
	apiRouter.HandleFunc("/heatmap", handleHeatmap).Methods("GET")
	apiRouter.HandleFunc("/timerange", handleTimeRange).Methods("GET")

	// Serve static files
	router.PathPrefix("/").Handler(http.FileServer(http.Dir("public")))

	// HTTP server
	httpServer := &http.Server{
		Addr:    fmt.Sprintf(":%d", config.APIPort),
		Handler: router,
	}

	// HTTPS server
	var httpsServer *http.Server
	var http3Server *http3.Server

	// Check if certificates exist
	if _, err := os.Stat(config.CertPath); err == nil {
		if _, err := os.Stat(config.PrivKeyPath); err == nil {
			// Create HTTPS server
			httpsServer = &http.Server{
				Addr:    fmt.Sprintf(":%d", config.APIPortHTTPS),
				Handler: router,
				TLSConfig: &tls.Config{
					MinVersion: tls.VersionTLS12,
				},
			}

			// Create HTTP/3 server
			http3Server = &http3.Server{
				Addr:    fmt.Sprintf(":%d", config.APIPortHTTP3),
				Handler: router,
				TLSConfig: &tls.Config{
					MinVersion: tls.VersionTLS12,
				},
			}
		}
	}

	return httpServer, httpsServer, http3Server
}

// Start the application
func startApplication() {
	// Log startup information
	log.Println("==============================================")
	log.Println("TRXUSDT Orderbook Heatmap Recorder Started")
	log.Printf("Symbol: %s", config.Symbol)
	log.Printf("Interval: %d seconds", config.Interval/time.Second)
	log.Printf("Orderbook Depth: %d", config.OrderbookDepth)
	log.Println("==============================================")

	// Start API server
	httpServer, httpsServer, http3Server := initializeAPI()

	// Start HTTP server
	go func() {
		log.Printf("HTTP server running on port %d", config.APIPort)
		if err := httpServer.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Fatalf("HTTP server error: %v", err)
		}
	}()

	// Start HTTPS server if certificates exist
	if httpsServer != nil {
		go func() {
			log.Printf("HTTPS server running on port %d", config.APIPortHTTPS)
			if err := httpsServer.ListenAndServeTLS(config.CertPath, config.PrivKeyPath); err != nil && err != http.ErrServerClosed {
				log.Printf("HTTPS server error: %v", err)
			}
		}()

		// Start HTTP/3 server if certificates exist
		if http3Server != nil {
			go func() {
				log.Printf("HTTP/3 server running on port %d", config.APIPortHTTP3)
				if err := http3Server.ListenAndServeTLS(config.CertPath, config.PrivKeyPath); err != nil {
					log.Printf("HTTP/3 server error: %v", err)
				}
			}()
		}
	} else {
		log.Printf("SSL certificates not found at %s. HTTPS and HTTP/3 servers not started.", config.CertPath)
	}

	// Execute immediately on startup
	scheduleDataCollection()

	// Schedule recurring execution
	ticker := time.NewTicker(config.Interval)

	// Set up graceful shutdown
	stop := make(chan os.Signal, 1)
	signal.Notify(stop, os.Interrupt, syscall.SIGTERM)

	// Main loop
	for {
		select {
		case <-ticker.C:
			go scheduleDataCollection()
		case <-stop:
			log.Println("Shutting down application...")
			ticker.Stop()

			// Shutdown HTTP, HTTPS and HTTP/3 servers
			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()

			httpServer.Shutdown(ctx)
			if httpsServer != nil {
				httpsServer.Shutdown(ctx)
			}
			// Note: HTTP/3 server doesn't have the same Shutdown method
			// It will close when the application exits

			log.Println("Database connection closed")
			return
		}
	}
}
