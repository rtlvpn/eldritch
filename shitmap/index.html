<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRXUSDT Orderbook Heatmap</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-chart-financial"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #121212;
            color: #e0e0e0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .chart-container {
            position: relative;
            height: 70vh;
            width: 100%;
            margin-bottom: 20px;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        button, select {
            background-color: #333;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover, select:hover {
            background-color: #444;
        }
        #heatmapCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>TRXUSDT Orderbook Heatmap</h1>
        
        <div class="controls">
            <label for="timeRange">Time Range:</label>
            <select id="timeRange">
                <option value="3600">Last Hour</option>
                <option value="14400">Last 4 Hours</option>
                <option value="86400">Last 24 Hours</option>
            </select>
            
            <button id="refreshBtn">Refresh Data</button>
        </div>
        
        <div class="chart-container">
            <canvas id="priceChart"></canvas>
            <canvas id="heatmapCanvas"></canvas>
        </div>
    </div>

    <script>
        // Chart instances
        let priceChart = null;
        
        // Get DOM elements
        const timeRangeSelect = document.getElementById('timeRange');
        const refreshBtn = document.getElementById('refreshBtn');
        const priceChartCanvas = document.getElementById('priceChart');
        const heatmapCanvas = document.getElementById('heatmapCanvas');
        
        // Resize heatmap canvas to match price chart
        function resizeHeatmapCanvas() {
            const chartRect = priceChartCanvas.getBoundingClientRect();
            heatmapCanvas.width = chartRect.width;
            heatmapCanvas.height = chartRect.height;
            heatmapCanvas.style.width = `${chartRect.width}px`;
            heatmapCanvas.style.height = `${chartRect.height}px`;
        }
        
        // Initialize the chart
        function initChart() {
            const ctx = priceChartCanvas.getContext('2d');
            
            priceChart = new Chart(ctx, {
                type: 'candlestick',
                data: {
                    datasets: [{
                        label: 'TRXUSDT',
                        data: []
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                unit: 'minute'
                            }
                        },
                        y: {
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Price (USDT)'
                            }
                        }
                    }
                }
            });
        }
        
        // Fetch and update data
        async function updateData() {
            const timeRange = parseInt(timeRangeSelect.value);
            const endTime = Math.floor(Date.now() / 1000);
            const startTime = endTime - timeRange;
            
            try {
                // Fetch candlestick data
                const candleResponse = await fetch(`https://heatmapeldritch.gleeze.com:3500/api/candlesticks?startTime=${startTime}&endTime=${endTime}`);
                const candleData = await candleResponse.json();
                
                // Format data for chart.js
                const formattedCandles = candleData.map(candle => ({
                    x: new Date(candle.timestamp),
                    o: candle.open,
                    h: candle.high,
                    l: candle.low,
                    c: candle.close
                }));
                
                // Update candlestick chart
                priceChart.data.datasets[0].data = formattedCandles;
                priceChart.update();
                
                // Fetch heatmap data
                const heatmapResponse = await fetch(`https://heatmapeldritch.gleeze.com:3500/api/heatmap?startTime=${startTime}&endTime=${endTime}`);
                const heatmapData = await heatmapResponse.json();
                
                // Draw heatmap overlay
                drawHeatmap(heatmapData);
                
            } catch (error) {
                console.error('Error fetching data:', error);
            }
        }
        
        // Draw the heatmap overlay
        function drawHeatmap(data) {
            resizeHeatmapCanvas();
            
            const ctx = heatmapCanvas.getContext('2d');
            ctx.clearRect(0, 0, heatmapCanvas.width, heatmapCanvas.height);
            
            if (!data.timestamps.length || !data.priceLevels.length) {
                return;
            }
            
            // Create a heatmap color scale
            const colorScale = d3.scaleSequential(d3.interpolateViridis)
                .domain([-1, 1]); // -1 = sell, 1 = buy
            
            // Get chart scales
            const xScale = priceChart.scales.x;
            const yScale = priceChart.scales.y;
            
            // Cell dimensions
            const cellWidth = xScale.width / data.timestamps.length;
            const cellHeight = yScale.height / data.priceLevels.length;
            
            // Get min/max volume for normalization
            let maxVolume = 0;
            for (const point of data.heatmap) {
                for (const volume of point.volumes) {
                    maxVolume = Math.max(maxVolume, Math.abs(volume));
                }
            }
            
            // Draw heatmap cells
            data.heatmap.forEach((point, timeIndex) => {
                const x = xScale.left + timeIndex * cellWidth;
                
                point.volumes.forEach((volume, priceIndex) => {
                    if (volume === 0) return; // Skip empty cells
                    
                    const priceLevel = data.priceLevels[priceIndex];
                    const y = yScale.getPixelForValue(priceLevel) - cellHeight/2;
                    
                    // Normalize volume for color intensity (-1 to 1)
                    const intensity = (volume / maxVolume) * (volume > 0 ? 1 : -1);
                    
                    // Set color based on side (buy/sell)
                    ctx.fillStyle = colorScale(intensity);
                    
                    // Draw rectangle
                    ctx.fillRect(x, y, cellWidth, cellHeight);
                });
            });
            
            // Add yellow lines for high volume areas
            ctx.strokeStyle = 'yellow';
            ctx.lineWidth = 1;
            
            // Find high volume price levels
            const aggregatedVolumes = new Array(data.priceLevels.length).fill(0);
            
            // Sum volumes across all timestamps
            data.heatmap.forEach(point => {
                point.volumes.forEach((volume, i) => {
                    aggregatedVolumes[i] += Math.abs(volume);
                });
            });
            
            // Find top 20% of volume concentrations
            const sortedVolumes = [...aggregatedVolumes].sort((a, b) => b - a);
            const threshold = sortedVolumes[Math.floor(sortedVolumes.length * 0.2)];
            
            // Draw lines at high volume price levels
            aggregatedVolumes.forEach((volume, i) => {
                if (volume >= threshold) {
                    const y = yScale.getPixelForValue(data.priceLevels[i]);
                    ctx.beginPath();
                    ctx.moveTo(xScale.left, y);
                    ctx.lineTo(xScale.right, y);
                    ctx.stroke();
                }
            });
        }
        
        // Event listeners
        refreshBtn.addEventListener('click', updateData);
        timeRangeSelect.addEventListener('change', updateData);
        
        // Initialize
        window.addEventListener('load', () => {
            initChart();
            updateData();
            
            // Handle window resize
            window.addEventListener('resize', () => {
                resizeHeatmapCanvas();
                if (priceChart) {
                    priceChart.resize();
                }
            });
        });
    </script>
</body>
</html>
