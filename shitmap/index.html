<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TRXUSDT Advanced Orderbook Heatmap</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #0a0a1a;
            color: #fff;
            font-family: monospace;
            overflow: hidden;
        }
        
        #header {
            background-color: #0a0a1a;
            padding: 5px 10px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #333;
        }
        
        #title {
            font-weight: bold;
        }
        
        #data {
            text-align: right;
        }
        
        .price { color: #FFD700; }
        .bid { color: #0f0; }
        .ask { color: #f00; }
        .negative { color: #f00; }
        
        #status {
            position: absolute;
            left: 10px;
            top: 30px;
            color: #0f0;
            z-index: 100;
            font-size: 11px;
            background-color: rgba(0,0,0,0.5);
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        #chart {
            position: relative;
            width: 100vw;
            height: calc(100vh - 25px);
        }
        
        #priceDisplay {
            position: absolute;
            right: 0;
            background-color: #f00;
            padding: 2px 5px;
            font-size: 12px;
            z-index: 10;
        }
        
        #timeDisplay {
            position: absolute;
            right: 60px;
            bottom: 10px;
            background-color: #f00;
            padding: 2px 5px;
            font-size: 11px;
            z-index: 10;
        }
        
        #priceAxis {
            position: absolute;
            right: 0;
            top: 0;
            width: 60px;
            height: 100%;
            color: #fff;
            text-align: right;
            font-size: 12px;
            padding-right: 5px;
            box-sizing: border-box;
            line-height: 1;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="header">
        <div id="title">TRXUSDT Orderbook Heatmap</div>
        <div id="data">
            Price: <span class="price">0.0000</span> | 
            Bid: <span class="bid">0.0000</span> | 
            Ask: <span class="ask">0.0000</span> | 
            Spread: <span id="spread">0.000000</span> | 
            Imbalance: <span id="imbalance" class="negative">0.00%</span>
        </div>
    </div>
    
    <div id="status">Connected</div>
    
    <div id="chart">
        <canvas id="heatmap"></canvas>
        <canvas id="overlay"></canvas>
        <div id="priceDisplay">0.0000</div>
        <div id="timeDisplay">00:00</div>
        <div id="priceAxis"></div>
    </div>
    
    <script>
        // Configuration
        const wsUrl = 'wss://heatmapeldritch.gleeze.com:3500';
        
        // DOM elements
        const heatmapCanvas = document.getElementById('heatmap');
        const overlayCanvas = document.getElementById('overlay');
        const priceDisplay = document.getElementById('priceDisplay');
        const timeDisplay = document.getElementById('timeDisplay');
        const priceAxis = document.getElementById('priceAxis');
        const status = document.getElementById('status');
        
        // Canvas context
        const heatmapCtx = heatmapCanvas.getContext('2d');
        const overlayCtx = overlayCanvas.getContext('2d');
        
        // State
        let heatmapData = null;
        let lastHeatmapUpdate = 0;
        
        // Resize canvases to full window
        function resizeCanvases() {
            const chart = document.getElementById('chart');
            const width = chart.clientWidth;
            const height = chart.clientHeight;
            
            heatmapCanvas.width = width;
            heatmapCanvas.height = height;
            overlayCanvas.width = width;
            overlayCanvas.height = height;
            
            if (heatmapData) {
                renderHeatmap();
            }
        }
        
        // Connect to WebSocket
        function connect() {
            const socket = new WebSocket(wsUrl);
            
            socket.onopen = () => {
                status.textContent = 'Connected';
                
                // Subscribe to data feeds
                socket.send(JSON.stringify({
                    action: 'subscribe',
                    topics: ['heatmap', 'orderbook']
                }));
            };
            
            socket.onclose = () => {
                status.textContent = 'Disconnected';
                setTimeout(connect, 2000);
            };
            
            socket.onerror = (err) => {
                status.textContent = 'Error';
                console.error('WebSocket error:', err);
            };
            
            socket.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    
                    if (message.type === 'orderbook') {
                        updateHeader(message.data);
                    }
                    else if (message.type === 'heatmap') {
                        heatmapData = message.data;
                        lastHeatmapUpdate = Date.now();
                        renderHeatmap();
                    }
                } catch (err) {
                    console.error('Error processing message', err);
                }
            };
        }
        
        // Update header with orderbook data
        function updateHeader(data) {
            if (!data || !data.metrics) return;
            
            document.querySelector('.price').textContent = data.metrics.midPrice.toFixed(4);
            document.querySelector('.bid').textContent = data.metrics.bestBid.toFixed(4);
            document.querySelector('.ask').textContent = data.metrics.bestAsk.toFixed(4);
            document.getElementById('spread').textContent = data.metrics.spread.toFixed(6);
            
            const imbalanceEl = document.getElementById('imbalance');
            const imbalanceVal = (data.metrics.imbalance * 100).toFixed(2);
            imbalanceEl.textContent = imbalanceVal + '%';
            imbalanceEl.className = data.metrics.imbalance >= 0 ? 'bid' : 'negative';
        }
        
        // Render heatmap visualization
        function renderHeatmap() {
            if (!heatmapData) return;
            
            const width = heatmapCanvas.width;
            const height = heatmapCanvas.height;
            const effectiveWidth = width - 60; // Account for price axis
            
            // Clear canvases
            heatmapCtx.clearRect(0, 0, width, height);
            overlayCtx.clearRect(0, 0, width, height);
            
            // Extract data
            const { times, prices, bidVolumes, askVolumes, midPrices, currentPrice, minPrice, maxPrice } = heatmapData;
            
            if (!times || times.length === 0) return;
            
            // Calculate scale factors
            const priceRange = maxPrice - minPrice;
            const priceToY = (price) => height - ((price - minPrice) / priceRange) * height;
            
            // Fill the background
            heatmapCtx.fillStyle = '#0a0a1a';
            heatmapCtx.fillRect(0, 0, width, height);
            
            // Add a slight grid pattern
            heatmapCtx.strokeStyle = 'rgba(50, 50, 90, 0.15)';
            heatmapCtx.lineWidth = 1;
            
            // Vertical grid lines (time)
            for (let i = 0; i < times.length; i += Math.max(1, Math.floor(times.length / 20))) {
                const x = (i / times.length) * effectiveWidth;
                heatmapCtx.beginPath();
                heatmapCtx.moveTo(x, 0);
                heatmapCtx.lineTo(x, height);
                heatmapCtx.stroke();
            }
            
            // Horizontal grid lines (price)
            for (let price = Math.ceil(minPrice * 100) / 100; price <= maxPrice; price += priceRange / 15) {
                const y = priceToY(price);
                heatmapCtx.beginPath();
                heatmapCtx.moveTo(0, y);
                heatmapCtx.lineTo(effectiveWidth, y);
                heatmapCtx.stroke();
            }
            
            // Find global max volume for color scaling
            let maxVolume = 0;
            for (let t = 0; t < times.length; t++) {
                if (!bidVolumes[t] || !askVolumes[t]) continue;
                
                for (let p = 0; p < prices.length; p++) {
                    const bidVol = bidVolumes[t][p] || 0;
                    const askVol = askVolumes[t][p] || 0;
                    maxVolume = Math.max(maxVolume, bidVol, askVol);
                }
            }
            
            // Apply a logarithmic scale for better visualization
            const logScale = (vol) => maxVolume > 0 ? Math.log(1 + vol) / Math.log(1 + maxVolume) : 0;
            
            // Draw heatmap cells for each time and price point
            const timeStep = effectiveWidth / times.length;
            const priceStep = height / prices.length;
            
            // Draw bid/ask liquidity as heatmap
            for (let t = 0; t < times.length; t++) {
                const x = t * timeStep;
                
                if (!bidVolumes[t] || !askVolumes[t]) continue;
                
                for (let p = 0; p < prices.length; p++) {
                    const price = prices[p];
                    const y = priceToY(price);
                    
                    const bidVol = bidVolumes[t][p] || 0;
                    const askVol = askVolumes[t][p] || 0;
                    
                    if (bidVol > 0) {
                        // Yellow/green for bids
                        const intensity = logScale(bidVol);
                        if (intensity > 0.05) { // Only draw significant volumes
                            heatmapCtx.fillStyle = getBidColor(intensity);
                            heatmapCtx.fillRect(x, y, timeStep + 0.5, priceStep + 0.5);
                        }
                    }
                    if (askVol > 0) {
                        // Cyan/blue for asks
                        const intensity = logScale(askVol);
                        if (intensity > 0.05) { // Only draw significant volumes
                            heatmapCtx.fillStyle = getAskColor(intensity);
                            heatmapCtx.fillRect(x, y, timeStep + 0.5, priceStep + 0.5);
                        }
                    }
                }
            }
            
            // Update price axis
            updatePriceAxis(minPrice, maxPrice, priceToY);
            
            // Draw current price line
            if (currentPrice) {
                const y = priceToY(currentPrice);
                
                // Draw red horizontal line at current price
                overlayCtx.beginPath();
                overlayCtx.strokeStyle = 'rgba(255, 51, 51, 0.8)';
                overlayCtx.lineWidth = 1;
                overlayCtx.setLineDash([5, 3]);
                overlayCtx.moveTo(0, y);
                overlayCtx.lineTo(effectiveWidth, y);
                overlayCtx.stroke();
                overlayCtx.setLineDash([]);
                
                // Update price display
                priceDisplay.style.top = (y - 10) + 'px';
                priceDisplay.textContent = currentPrice.toFixed(4);
            }
            
            // Draw price history if available
            if (midPrices && midPrices.length > 0) {
                // Draw candlestick/line chart overlay
                overlayCtx.beginPath();
                overlayCtx.strokeStyle = 'rgba(255, 215, 0, 0.9)'; // Gold/yellow
                overlayCtx.lineWidth = 1.5;
                
                for (let i = 0; i < midPrices.length; i++) {
                    const x = (i / midPrices.length) * effectiveWidth;
                    const y = priceToY(midPrices[i]);
                    
                    if (i === 0) {
                        overlayCtx.moveTo(x, y);
                    } else {
                        overlayCtx.lineTo(x, y);
                    }
                }
                
                overlayCtx.stroke();
            }
            
            // Update time display
            if (times.length > 0) {
                const lastTime = times[times.length - 1];
                let timeStr = lastTime;
                if (lastTime.includes(' ')) {
                    timeStr = lastTime.split(' ')[1].substring(0, 5); // Extract HH:MM
                }
                timeDisplay.textContent = timeStr;
            }
        }
        
        // Generate color for bid volumes
        function getBidColor(intensity) {
            // Yellow to green range for bids
            const r = Math.floor(255 * Math.min(1, intensity * 1.5));
            const g = Math.floor(255 * Math.min(1, intensity * 1.3));
            const b = Math.floor(50 * intensity);
            const alpha = 0.2 + intensity * 0.8;
            
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Generate color for ask volumes
        function getAskColor(intensity) {
            // Cyan to blue range for asks
            const r = Math.floor(100 * intensity);
            const g = Math.floor(200 * intensity);
            const b = Math.floor(255 * intensity);
            const alpha = 0.2 + intensity * 0.8;
            
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        // Update price axis with labels at appropriate intervals
        function updatePriceAxis(minPrice, maxPrice, priceToY) {
            priceAxis.innerHTML = '';
            const priceRange = maxPrice - minPrice;
            const step = calculateNiceStep(priceRange / 10);
            
            // Start at a "nice" value
            const startPrice = Math.ceil(minPrice / step) * step;
            
            for (let price = startPrice; price <= maxPrice; price += step) {
                const y = priceToY(price);
                
                const label = document.createElement('div');
                label.style.position = 'absolute';
                label.style.top = (y - 6) + 'px';
                label.textContent = price.toLocaleString(undefined, {
                    minimumFractionDigits: getDecimalPlaces(step),
                    maximumFractionDigits: getDecimalPlaces(step)
                });
                priceAxis.appendChild(label);
            }
        }
        
        // Calculate a nice step size (1, 2, 5, 10, 20, 50, etc.)
        function calculateNiceStep(roughStep) {
            const exponent = Math.floor(Math.log10(roughStep));
            const fraction = roughStep / Math.pow(10, exponent);
            
            if (fraction < 1.5) return Math.pow(10, exponent);
            if (fraction < 3.5) return 2 * Math.pow(10, exponent);
            if (fraction < 7.5) return 5 * Math.pow(10, exponent);
            return 10 * Math.pow(10, exponent);
        }
        
        // Get appropriate decimal places based on step size
        function getDecimalPlaces(step) {
            if (step >= 1) return 0;
            return Math.ceil(Math.abs(Math.log10(step)));
        }
        
        // Animation loop for smooth rendering
        function animate() {
            requestAnimationFrame(animate);
            
            // Only re-render if we have new data or window was resized
            if (heatmapData && lastHeatmapUpdate > 0) {
                // Not rendering every frame to save CPU
                // but ensuring we always show latest data
                if (Date.now() - lastHeatmapUpdate < 500) {
                    renderHeatmap();
                    lastHeatmapUpdate = 0; // Mark as rendered
                }
            }
        }
        
        // Initialize
        window.addEventListener('load', () => {
            resizeCanvases();
            connect();
            animate(); // Start animation loop
        });
        
        window.addEventListener('resize', resizeCanvases);
    </script>
</body>
</html>
