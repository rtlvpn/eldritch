<!DOCTYPE html>
<html>
<head>
    <title>Transfers Monitor</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        body {
            background: #0a0a0a;
            margin: 0;
            font-family: 'Segoe UI', sans-serif;
        }
        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 20px;
        }
        .chart-header {
            color: #fff;
            padding: 20px 0;
            border-bottom: 1px solid #2a2a2a;
        }
        .btn-group {
            margin: 20px 0;
            display: flex;
            gap: 10px;
        }
        .btn {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #4ecdc4;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn:hover {
            background: #4ecdc4;
            color: #121212;
        }
        .btn.active {
            background: #4ecdc4;
            color: #121212;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="chart-header">Real-time Transfer Analytics</h1>
        <div class="btn-group">
            <button class="btn active" id="btn-1m">1 Minute Intervals</button>
            <button class="btn" id="btn-5m">5 Minute Aggregation</button>
        </div>
        <div id="chart"></div>
    </div>

    <script>
        // Mobile detection (skip divergence computation on mobile devices)
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);

        let rawData = [];
        let isLoading = false;
        let hasMoreData = true;
        let currentPage = 1;
        const RECORDS_PER_PAGE = 1000;
        let aggregatedCache = {};

        async function fetchTransferData() {
            if (isLoading || !hasMoreData) return rawData;
            try {
                isLoading = true;
                const response = await fetch(`https://eldritch.gleeze.com:3000/transfers/paginated?page=${currentPage}&limit=${RECORDS_PER_PAGE}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const result = await response.json();
                const newData = result.data;
                // Merge incoming data and sort by timestamp
                rawData = [...rawData, ...newData].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                hasMoreData = currentPage < result.total_pages;
                currentPage++;
                // Invalidate the cache when new data is added.
                aggregatedCache = {};
                return rawData;
            } catch (error) {
                console.error('Fetch error:', error);
                return rawData;
            } finally {
                isLoading = false;
            }
        }

        async function loadAllData() {
            while (hasMoreData) {
                await fetchTransferData();
            }
            return rawData;
        }

        function aggregateData(intervalMinutes) {
            if (aggregatedCache[intervalMinutes]) return aggregatedCache[intervalMinutes];
            const aggregated = {};
            const priceAggregated = {};
            const priceCount = {};
            const intervalMs = intervalMinutes * 60 * 1000;
            for (let i = 0; i < rawData.length; i++) {
                const item = rawData[i];
                const date = new Date(item.timestamp);
                const rounded = new Date(Math.floor(date.getTime() / intervalMs) * intervalMs);
                const key = rounded.toISOString();
                aggregated[key] = (aggregated[key] || 0) + item.count;
                if (item.trx_price) {
                    priceAggregated[key] = (priceAggregated[key] || 0) + item.trx_price;
                    priceCount[key] = (priceCount[key] || 0) + 1;
                }
            }
            const keys = Object.keys(aggregated).sort();
            const timestamps = new Array(keys.length);
            const counts = new Array(keys.length);
            const prices = new Array(keys.length);
            for (let i = 0; i < keys.length; i++) {
                timestamps[i] = new Date(keys[i]);
                counts[i] = aggregated[keys[i]];
                prices[i] = priceCount[keys[i]] ? priceAggregated[keys[i]] / priceCount[keys[i]] : null;
            }
            const aggregatedData = { timestamps, counts, prices };
            aggregatedCache[intervalMinutes] = aggregatedData;
            return aggregatedData;
        }

        /*
         * Computes a Price-Transfer Divergence indicator.
         * It only considers intervals where valid price data exists.
         */
        function computePriceTransferDivergence(aggregated) {
            const { timestamps, counts, prices } = aggregated;
            const n = timestamps.length;
            const transferDiff = new Array(n).fill(null);
            const priceDiff = new Array(n).fill(null);
            const validIndices = [];

            for (let i = 1; i < n; i++) {
                if (prices[i] !== null && prices[i - 1] !== null) {
                    transferDiff[i] = counts[i] - counts[i - 1];
                    priceDiff[i] = prices[i] - prices[i - 1];
                    validIndices.push(i);
                }
            }

            const validTransferDiff = validIndices.map(i => transferDiff[i]);
            const validPriceDiff = validIndices.map(i => priceDiff[i]);
            const minTransfer = Math.min(...validTransferDiff);
            const maxTransfer = Math.max(...validTransferDiff);
            const minPrice = Math.min(...validPriceDiff);
            const maxPrice = Math.max(...validPriceDiff);
            const divergence = new Array(n).fill(null);

            for (const i of validIndices) {
                const normTransfer = (maxTransfer === minTransfer)
                    ? 0 
                    : (transferDiff[i] - minTransfer) / (maxTransfer - minTransfer);
                const normPrice = (maxPrice === minPrice)
                    ? 0 
                    : (priceDiff[i] - minPrice) / (maxPrice - minPrice);
                divergence[i] = normTransfer - normPrice;
            }
            return { timestamps, divergence };
        }

        /*
         * Advanced implementation of the Least Action Principle for market prediction.
         * Uses phase space dynamics and calculates potential future trajectories.
         */
        function computePredictiveLeastAction(aggregated) {
            const { timestamps, counts, prices } = aggregated;
            const n = timestamps.length;
            const leastAction = new Array(n).fill(null);
            const prediction = new Array(n).fill(null);
            const momentum = new Array(n).fill(null);
            const validIndices = [];
            const lookback = 5; // Window size for momentum calculation
            
            // Identify valid data points and compute phase space coordinates
            for (let i = lookback; i < n; i++) {
                if (prices[i] !== null && counts[i] !== null) {
                    validIndices.push(i);
                }
            }

            if (validIndices.length < lookback + 2) return { timestamps, leastAction, prediction, momentum };

            // Calculate phase space coordinates (price, transfer count, price velocity, transfer velocity)
            const phaseSpace = validIndices.map(i => {
                const priceVelocity = (prices[i] - prices[i-1]) || 0;
                const countVelocity = (counts[i] - counts[i-1]) || 0;
                
                // Calculate momentum as moving average of velocities
                let priceMomentum = 0, countMomentum = 0;
                for (let j = 0; j < lookback; j++) {
                    if (i-j > 0 && prices[i-j] !== null && prices[i-j-1] !== null) {
                        priceMomentum += (prices[i-j] - prices[i-j-1]);
                        countMomentum += (counts[i-j] - counts[i-j-1]);
                    }
                }
                priceMomentum /= lookback;
                countMomentum /= lookback;
                
                return {
                    index: i,
                    price: prices[i],
                    count: counts[i],
                    priceVelocity,
                    countVelocity,
                    priceMomentum,
                    countMomentum
                };
            });

            // Normalize phase space coordinates
            const priceValues = phaseSpace.map(p => p.price);
            const countValues = phaseSpace.map(p => p.count);
            const priceVelocities = phaseSpace.map(p => p.priceVelocity);
            const countVelocities = phaseSpace.map(p => p.countVelocity);
            
            const priceMean = priceValues.reduce((a, b) => a + b, 0) / priceValues.length;
            const countMean = countValues.reduce((a, b) => a + b, 0) / countValues.length;
            const priceVelMean = priceVelocities.reduce((a, b) => a + b, 0) / priceVelocities.length;
            const countVelMean = countVelocities.reduce((a, b) => a + b, 0) / countVelocities.length;
            
            const priceStd = Math.sqrt(priceValues.reduce((a, b) => a + Math.pow(b - priceMean, 2), 0) / priceValues.length) || 1;
            const countStd = Math.sqrt(countValues.reduce((a, b) => a + Math.pow(b - countMean, 2), 0) / countValues.length) || 1;
            const priceVelStd = Math.sqrt(priceVelocities.reduce((a, b) => a + Math.pow(b - priceVelMean, 2), 0) / priceVelocities.length) || 1;
            const countVelStd = Math.sqrt(countVelocities.reduce((a, b) => a + Math.pow(b - countVelMean, 2), 0) / countVelocities.length) || 1;
            
            // Calculate action as potential and kinetic energy in phase space
            for (const point of phaseSpace) {
                const i = point.index;
                const normPrice = (point.price - priceMean) / priceStd;
                const normCount = (point.count - countMean) / countStd;
                const normPriceVel = (point.priceVelocity - priceVelMean) / priceVelStd;
                const normCountVel = (point.countVelocity - countVelMean) / countVelStd;
                
                // Potential energy component (position mismatch)
                const potentialEnergy = Math.pow(normPrice - normCount, 2);
                
                // Kinetic energy component (velocity mismatch)
                const kineticEnergy = Math.pow(normPriceVel - normCountVel, 2);
                
                // Total action = potential + kinetic energy
                const action = potentialEnergy + kineticEnergy;
                
                // Least action (inverted, normalized between 0-1)
                leastAction[i] = Math.exp(-action / 2);
                
                // Calculate momentum signal for trend direction
                momentum[i] = Math.sign(point.priceMomentum) * Math.sign(point.countMomentum) * 
                             (Math.abs(point.priceMomentum) / priceVelStd) * 
                             (Math.abs(point.countMomentum) / countVelStd);
            }
            
            // Generate price prediction based on least action principle
            // When markets are in harmony (high least action), momentum continues
            // When markets are in disharmony (low least action), expect reversion
            for (let j = 0; j < validIndices.length; j++) {
                const i = validIndices[j];
                if (j >= 3 && j < validIndices.length - 1) {
                    const harmony = leastAction[i];
                    const momentumStrength = momentum[i];
                    
                    // Calculate predicted price movement
                    // High harmony → follow momentum
                    // Low harmony → expect reversion
                    if (harmony > 0.7) {
                        // In harmony state - expect trend continuation
                        prediction[i] = prices[i] * (1 + 0.005 * momentumStrength);
                    } else if (harmony < 0.3) {
                        // In disharmony state - expect reversion
                        prediction[i] = prices[i] * (1 - 0.003 * momentumStrength);
                    } else {
                        // Neutral state - slight bias toward momentum
                        prediction[i] = prices[i] * (1 + 0.001 * momentumStrength);
                    }
                }
            }
            
            return { timestamps, leastAction, prediction, momentum };
        }

        /*
         * Renders the Plotly chart.
         */
        async function renderChart(interval = 1) {
            let chartData, aggregated;
            if (interval === 1) {
                chartData = rawData;
                aggregated = aggregateData(1);
            } else {
                aggregated = aggregateData(interval);
                chartData = aggregated;
            }
            
            const xValues = interval === 1 
                ? rawData.map(d => new Date(d.timestamp)) 
                : aggregated.timestamps;
            const yValues = interval === 1 
                ? rawData.map(d => d.count) 
                : aggregated.counts;
            const priceValues = interval === 1 
                ? rawData.map(d => d.trx_price) 
                : aggregated.prices;

            const transferTrace = {
                x: xValues,
                y: yValues,
                type: 'scatter',
                mode: 'lines',
                name: 'Transfers',
                fill: 'tozeroy',
                fillcolor: interval === 1 ? 'rgba(78, 205, 196, 0.2)' : 'rgba(255, 107, 107, 0.2)',
                line: {
                    color: interval === 1 ? '#4ecdc4' : '#ff6b6b',
                    width: 2,
                    shape: 'spline'
                },
                hovertemplate: `<b>%{x|%H:%M:%S}</b><br>%{y} transfers<extra></extra>`,
                yaxis: 'y'
            };

            const priceTrace = {
                x: xValues,
                y: priceValues,
                type: 'scatter',
                mode: 'lines',
                name: 'Price',
                line: {
                    color: 'rgba(255, 215, 0, 0.6)',
                    width: 2,
                    shape: 'spline'
                },
                hovertemplate: `<b>%{x|%H:%M:%S}</b><br>$%{y:.4f}<extra></extra>`,
                yaxis: 'y2'
            };

            // Build the traces array; if not on mobile, add the divergence trace.
            const traces = [transferTrace, priceTrace];
            if (!isMobile) {
                const divergenceData = computePriceTransferDivergence(aggregated);
                const divergenceTrace = {
                    x: divergenceData.timestamps,
                    y: divergenceData.divergence,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Price-Transfer Divergence',
                    line: {
                        color: 'rgba(255, 215, 0, 0.2)',
                        width: 1,
                        dash: 'dot'
                    },
                    hovertemplate: `<b>%{x|%H:%M:%S}</b><br>Divergence: %{y:.2f}<extra></extra>`,
                    yaxis: 'y3'
                };
                traces.push(divergenceTrace);
                
                // Add advanced Least Action analysis
                const leastActionData = computePredictiveLeastAction(aggregated);
                
                // Harmony index trace
                const leastActionTrace = {
                    x: leastActionData.timestamps,
                    y: leastActionData.leastAction,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Quantum Harmony Index',
                    line: {
                        color: 'rgba(147, 112, 219, 0.8)', // Purple
                        width: 2
                    },
                    hovertemplate: `<b>%{x|%H:%M:%S}</b><br>Harmony: %{y:.2f}<extra></extra>`,
                    yaxis: 'y4'
                };
                traces.push(leastActionTrace);
                
                // Price prediction trace
                const predictionTrace = {
                    x: leastActionData.timestamps,
                    y: leastActionData.prediction,
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Price Prediction',
                    marker: {
                        color: 'rgba(255, 80, 80, 0.9)',
                        size: 4,
                        symbol: 'diamond'
                    },
                    hovertemplate: `<b>%{x|%H:%M:%S}</b><br>Predicted: $%{y:.4f}<extra></extra>`,
                    yaxis: 'y2'
                };
                traces.push(predictionTrace);
                
                // Momentum component trace
                const momentumTrace = {
                    x: leastActionData.timestamps,
                    y: leastActionData.momentum,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'Phase Momentum',
                    line: {
                        color: 'rgba(0, 255, 127, 0.6)', // Spring green
                        width: 1,
                        dash: 'dot'
                    },
                    hovertemplate: `<b>%{x|%H:%M:%S}</b><br>Momentum: %{y:.2f}<extra></extra>`,
                    yaxis: 'y5'
                };
                traces.push(momentumTrace);
            }

            const layout = {
                title: {
                    text: `Transfer & Price Analytics (${interval} Minute Intervals)`,
                    font: { color: '#fff', size: 22 }
                },
                plot_bgcolor: '#121212',
                paper_bgcolor: '#121212',
                xaxis: {
                    title: 'Time',
                    gridcolor: '#2a2a2a',
                    color: '#fff',
                    tickformat: '%H:%M'
                },
                yaxis: {
                    title: interval === 1 ? 'Transfer Count' : 'Aggregated Count',
                    gridcolor: '#2a2a2a',
                    color: '#fff',
                    zerolinecolor: '#2a2a2a',
                    rangemode: 'tozero',
                    autorange: true,
                    side: 'left'
                },
                yaxis2: {
                    title: 'Price (USDT)',
                    titlefont: { color: '#ffd700' },
                    tickfont: { color: '#ffd700' },
                    overlaying: 'y',
                    side: 'right',
                    gridcolor: 'rgba(255, 215, 0, 0.1)',
                    zerolinecolor: '#2a2a2a'
                },
                yaxis3: {
                    title: 'Divergence',
                    titlefont: { color: '#FFA500' },
                    tickfont: { color: '#FFA500' },
                    overlaying: 'y',
                    side: 'right',
                    position: 0.85,
                    gridcolor: 'rgba(255, 165, 0, 0.2)'
                },
                yaxis4: {
                    title: 'Quantum Harmony',
                    titlefont: { color: 'rgba(147, 112, 219, 0.8)' },
                    tickfont: { color: 'rgba(147, 112, 219, 0.8)' },
                    overlaying: 'y',
                    side: 'right',
                    position: 0.9,
                    range: [0, 1],
                    gridcolor: 'rgba(147, 112, 219, 0.2)'
                },
                yaxis5: {
                    title: 'Momentum',
                    titlefont: { color: 'rgba(0, 255, 127, 0.6)' },
                    tickfont: { color: 'rgba(0, 255, 127, 0.6)' },
                    overlaying: 'y',
                    side: 'right',
                    position: 0.95,
                    gridcolor: 'rgba(0, 255, 127, 0.2)'
                },
                font: { color: '#fff' },
                margin: { t: 60, l: 60, r: 60, b: 60 },
                hoverlabel: { bgcolor: '#121212', font: { color: '#fff' } },
                showlegend: true,
                legend: {
                    x: 0.5,
                    y: 1.1,
                    xanchor: 'center',
                    orientation: 'h',
                    font: { color: '#fff' }
                }
            };

            Plotly.newPlot('chart', traces, layout, { responsive: true });
        }

        // Button handlers.
        document.getElementById('btn-1m').addEventListener('click', () => {
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-1m').classList.add('active');
            renderChart(1);
        });

        document.getElementById('btn-5m').addEventListener('click', () => {
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-5m').classList.add('active');
            renderChart(5);
        });

        loadAllData().then(() => renderChart(1));
    </script>
</body>
</html>
