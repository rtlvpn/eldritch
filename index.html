<!DOCTYPE html>
<html>
<head>
    <title>TRC20 Transfers Monitor</title>
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <style>
        body {
            background: #0a0a0a;
            margin: 0;
            font-family: 'Segoe UI', sans-serif;
        }
        .container {
            max-width: 1400px;
            margin: 2rem auto;
            padding: 0 20px;
        }
        .chart-header {
            color: #fff;
            padding: 20px 0;
            border-bottom: 1px solid #2a2a2a;
        }
        .btn-group {
            margin: 20px 0;
            display: flex;
            gap: 10px;
        }
        .btn {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #4ecdc4;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn:hover {
            background: #4ecdc4;
            color: #121212;
        }
        .btn.active {
            background: #4ecdc4;
            color: #121212;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="chart-header">Real-time Transfer Analytics</h1>
        <div class="btn-group">
            <button class="btn active" id="btn-1m">1 Minute Intervals</button>
            <button class="btn" id="btn-5m">5 Minute Aggregation</button>
        </div>
        <div id="chart"></div>
    </div>

    <script>
        let rawData = [];
        let priceData = [];
        let isLoading = false;
        let hasMoreData = true;
        let currentPage = 1;
        const RECORDS_PER_PAGE = 1000;

        async function fetchTransferData() {
            if (isLoading || !hasMoreData) return rawData;
            
            try {
                isLoading = true;
                const response = await fetch(`https://eldritch.gleeze.com:3000/transfers/paginated?page=${currentPage}&limit=${RECORDS_PER_PAGE}`);
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                
                const result = await response.json();
                const newData = result.data;
                
                // Add new data to existing data
                rawData = [...rawData, ...newData].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                
                // Check if we have more pages to load
                hasMoreData = currentPage < result.total_pages;
                currentPage++;
                
                return rawData;
            } catch (error) {
                console.error('Fetch error:', error);
                return rawData;
            } finally {
                isLoading = false;
            }
        }

        async function fetchPriceData(startTime, endTime) {
            try {
                const MAX_INTERVAL = 1000 * 60 * 60 * 24; // 24 hours in milliseconds
                const allPriceData = [];
                let consecutiveErrors = 0;
                
                // Split into multiple requests if the time range is large
                for (let currentStart = startTime; currentStart < endTime; currentStart += MAX_INTERVAL) {
                    const currentEnd = Math.min(currentStart + MAX_INTERVAL, endTime);
                    
                    try {
                        const response = await fetch(
                            `https://api.binance.com/api/v3/klines?symbol=TRXUSDT&interval=1m&startTime=${currentStart}&endTime=${currentEnd}&limit=1000`
                        );
                        
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        
                        const data = await response.json();
                        const processedData = data.map(item => ({
                            timestamp: new Date(item[0]),
                            price: parseFloat(item[4])
                        }));
                        
                        allPriceData.push(...processedData);
                        consecutiveErrors = 0;
                        
                        // Log progress
                        console.log(`Fetched price data from ${new Date(currentStart).toISOString()} to ${new Date(currentEnd).toISOString()}`);
                        
                    } catch (error) {
                        console.error(`Error fetching price data for range ${new Date(currentStart)} - ${new Date(currentEnd)}:`, error);
                        consecutiveErrors++;
                        
                        if (consecutiveErrors >= 3) {
                            console.error('Too many consecutive errors, stopping price data fetch');
                            break;
                        }
                    }
                    
                    // Add a delay between requests to avoid rate limiting
                    await new Promise(resolve => setTimeout(resolve, 250));
                }
                
                console.log(`Total price data points fetched: ${allPriceData.length}`);
                
                // Sort and remove any duplicates
                const uniquePriceData = Array.from(
                    new Map(allPriceData.map(item => [item.timestamp.getTime(), item]))
                    .values()
                ).sort((a, b) => a.timestamp - b.timestamp);
                
                return uniquePriceData;
                
            } catch (error) {
                console.error('Price fetch error:', error);
                return [];
            }
        }

        async function loadAllData() {
            while (hasMoreData) {
                await fetchTransferData();
            }
            
            if (rawData.length > 0) {
                const startTime = new Date(rawData[0].timestamp).getTime();
                const endTime = new Date(rawData[rawData.length - 1].timestamp).getTime();
                priceData = await fetchPriceData(startTime, endTime);
            }
            
            return rawData;
        }

        function aggregateData(intervalMinutes) {
            const aggregated = {};
            rawData.forEach(item => {
                const date = new Date(item.timestamp);
                const interval = intervalMinutes * 60 * 1000; // milliseconds
                const rounded = new Date(Math.floor(date.getTime() / interval) * interval);
                
                const key = rounded.toISOString();
                aggregated[key] = (aggregated[key] || 0) + item.count;
            });

            return {
                timestamps: Object.keys(aggregated).map(k => new Date(k)),
                counts: Object.values(aggregated)
            };
        }

        async function renderChart(interval = 1) {
            const data = interval === 1 ? rawData : aggregateData(interval);
            const xValues = interval === 1 ? data.map(d => new Date(d.timestamp)) : data.timestamps;
            const yValues = interval === 1 ? data.map(d => d.count) : data.counts;

            const traces = [
                {
                    x: xValues,
                    y: yValues,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'TRC20 Transfers',
                    fill: 'tozeroy',
                    fillcolor: interval === 1 ? 'rgba(78, 205, 196, 0.2)' : 'rgba(255, 107, 107, 0.2)',
                    line: {
                        color: interval === 1 ? '#4ecdc4' : '#ff6b6b',
                        width: 2,
                        shape: 'spline'
                    },
                    hovertemplate: `<b>%{x|%H:%M:%S}</b><br>${interval === 1 ? '%{y} transfers' : '%{y} total transfers'}<extra></extra>`
                },
                {
                    x: priceData.map(d => d.timestamp),
                    y: priceData.map(d => d.price),
                    type: 'scatter',
                    mode: 'lines',
                    name: 'TRON Price',
                    yaxis: 'y2',
                    line: {
                        color: '#ffd700',
                        width: 2
                    },
                    hovertemplate: '<b>%{x|%H:%M:%S}</b><br>$%{y:.4f}<extra></extra>'
                }
            ];

            const layout = {
                title: {
                    text: `Transfer Frequency (${interval} Minute Intervals) & TRON Price`,
                    font: { color: '#fff', size: 22 }
                },
                plot_bgcolor: '#121212',
                paper_bgcolor: '#121212',
                xaxis: {
                    title: 'Time',
                    gridcolor: '#2a2a2a',
                    color: '#fff',
                    tickformat: interval === 1 ? '%H:%M' : '%H:%M'
                },
                yaxis: {
                    title: interval === 1 ? 'Transfer Count' : 'Aggregated Count',
                    gridcolor: '#2a2a2a',
                    color: '#fff',
                    zerolinecolor: '#2a2a2a',
                    rangemode: 'tozero',
                    autorange: true
                },
                yaxis2: {
                    title: 'TRON Price (USDT)',
                    titlefont: { color: '#ffd700' },
                    tickfont: { color: '#ffd700' },
                    overlaying: 'y',
                    side: 'right',
                    gridcolor: '#2a2a2a',
                    zerolinecolor: '#2a2a2a'
                },
                font: { color: '#fff' },
                margin: { t: 60, l: 60, r: 60, b: 60 },
                hoverlabel: {
                    bgcolor: '#121212',
                    bordercolor: interval === 1 ? '#4ecdc4' : '#ff6b6b',
                    font: { color: '#fff' }
                },
                showlegend: true,
                legend: {
                    x: 0.5,
                    y: 1.1,
                    xanchor: 'center',
                    orientation: 'h',
                    font: { color: '#fff' }
                }
            };

            Plotly.newPlot('chart', traces, layout, { responsive: true });
        }

        // Button handlers
        document.getElementById('btn-1m').addEventListener('click', () => {
            currentAggregation = 1;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-1m').classList.add('active');
            renderChart(1);
        });

        document.getElementById('btn-5m').addEventListener('click', () => {
            currentAggregation = 5;
            document.querySelectorAll('.btn').forEach(b => b.classList.remove('active'));
            document.getElementById('btn-5m').classList.add('active');
            renderChart(5);
        });

        // Modify the initial load to use loadAllData
        loadAllData().then(() => renderChart(1));
    </script>
</body>
</html>
